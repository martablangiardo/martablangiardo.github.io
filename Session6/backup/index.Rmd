---
title: "Session 1.3: Introduction to geospatial data"
params: 
   conference: "Advanced Analytics"
   location: "Imperial College London"
   date: January-February 2023
   short_title: "Advanced Analytics"

output:
  xaringan::moon_reader: 
    includes: 
       in_header: "assets/latex_macros.html" 
       # This line adds a logo based on the format selected in the file 'assets/include_logo.html'
       # NB: the actual options (eg placement of the logo and actual logo file) can be changed there
   #    after_body: "assets/insert-logo.html" # Monica removed this
    seal: false
    yolo: no
    lib_dir: libs
    nature:
      beforeInit: ["https://platform.twitter.com/widgets.js"]
      highlightStyle: github
      highlightLines: yes
      countIncrementalSlides: no
      ratio: '16:9'
      titleSlideClass:
      - center
      - middle
    self_contained: false 
    css:
    - "assets/beamer.css"
---

```{r global_options, echo = FALSE, include = FALSE}
options(width = 999)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE,
                      cache = FALSE, tidy = FALSE, size = "small")
```
```{r echo=F,message=FALSE,warning=FALSE,comment=NA}
# Sources the R file with all the relevant setup and commands
source("assets/setup.R")
library(INLA)

# Stuff from 'xaringanExtra' (https://pkg.garrickadenbuie.com/xaringanExtra)
# This allows the use of panels (from 'xaringanExtra')
xaringanExtra::use_panelset()
# This allows to copy code from the slides directly
#xaringanExtra::use_clipboard()
# This freezes the frame for when there's a gif included
#xaringanExtra::use_freezeframe()

# Defines the path to the file with the .bib entries (in case there are references)

bibfile=RefManageR::ReadBib("~/Dropbox/TEACHING/YEAR_2023/Advanced_Analytics_2023/Material/Biblio.bib",check = FALSE)

#bibfile=ReadBib("C:/Users/Monica/Dropbox/VIBASS/Biblio.bib",check = FALSE)

#bibfile=ReadBib("~/Dropbox/Lavori condivisi/2015_Book/ShortCourse/VIBASS/Biblio.bib",check = FALSE)

```

class: title-slide

# `r rmarkdown::metadata$title``r vspace("10px")` `r rmarkdown::metadata$subtitle`

## `r rmarkdown::metadata$author`

### `r rmarkdown::metadata$institute`    

### `r rmarkdown::metadata$params$conference`, `r rmarkdown::metadata$params$location` 

<!-- Can also separate the various components of the extra argument 'params', eg as in 
### `r paste(rmarkdown::metadata$params, collapse=", ")`
-->

`r ifelse(is.null(rmarkdown::metadata$params$date),format(Sys.Date(),"%e %B %Y"),rmarkdown::metadata$params$date)`

---

layout: true  

.my-footer[ 
.alignleft[ 
&nbsp; &copy; Marta Blangiardo | Monica Pirani
]
.aligncenter[
`r rmarkdown::metadata$params$short_title` 
]
.alignright[
`r rmarkdown::metadata$params$conference`, `r short_date` 
]
] 

```{css,echo=FALSE, eval=FALSE}
.red {
  color: red;
}
.blue {
  color: 0.14 0.34 0.55;
}

.content-box-blue { background-color: #F0F8FF; }

}
```
<style>
pre {
  overflow-x: auto;
}
pre code {
  word-wrap: normal;
  white-space: pre;
}
</style>

---
# Learning objectives

After this lecture you should be able to 
`r vspace("40px")`

- Describe the different types of spatial data, and how they are represented in R 

`r vspace("40px")`

- Describe Coordinate Reference Systems (Geographical and Projected CRS)

`r vspace("40px")`

The topics treated in this lecture are presented in:


- Chapter 2 of the book **Geocomputation with R** https://geocompr.robinlovelace.net/index.html


- Chapter 2  of the book **Geospatial Health Data: Modeling and Visualization with R-INLA and Shiny**  https://www.paulamoraga.com/book-geospatial/index.html


---

# Outline 

`r vspace("30px")`

1\. [The different types of spatial data](#spatialData)

`r vspace("30px")`

2\. [Spatial data in R](#SpatialR)

`r vspace("30px")`

3\. [Coordinate Reference Systems ](#CRS)


---

name: spatialData
  
`r vspace("250px")`

.myblue[.center[.huge[
**What are the different types of spatial data?**]]]

---


# Terminology

- The data are seen as being a realization of a stochastic process, that is, of a set of random numbers each of which is associated with a spatial location.
  - A spatial process in $d$ dimensions is denoted as:

$$\{Z(\bm{s}): \bm{s} \in \mathcal{D} \subset \mathbb{R}^d \}$$ 

where
- $Z$ is the attribute we observe (e.g. temperature, number of sudden infant deaths etc.)
`r vspace("10px")`
- $\bm{s}$ is the location where $Z$ is observed (e.g. coordinates such as latitude and longitude)
`r vspace("10px")`
- $\mathcal{D}$ is the domain, and it is called the **index set** = possible locations

`r vspace("70px")`
- Symbols are as follows: $\{\}$ a set (a collection of elements); $\in$ element of or belongs to; $\subset$ subset of; $\mathbb{R}$ real numbers set

---

# Type of spatial data

`r Citet(bibfile,"Cressie:1993")` distinguishes three types of spatial data, based on the nature of the spatial domain $\mathcal{D}$:

`r vspace("20px")`

- .red[Areal data (also known as lattice data)]: $\mathcal{D}$ is fixed (of regular or irregular shape) and partitioned into a finite number of areal units (e.g. census tract, pixels) with well-defined boundaries. 

`r vspace("20px")`

- .red[Geostatistical (or point-referenced) data]: $\mathcal{D}$ is a continuous fixed set. By continuous we mean that $Z(\bm{s})$ can be observed everywhere within $\mathcal{D}$. By fixed we mean that the points in $\mathcal{D}$ are non-stochastic. 

`r vspace("20px")`

- .red[Point pattern data]: $\mathcal{D}$ is itself random. Its index set gives the locations of random **events** that are the spatial point pattern. 

---

# Example of areal data [1]

Lattice data can be either irregularly aligned or gridded, and occur in the form of aggregated observation over areas.
`r vspace("20px")`
.pull-left[`r include_fig("poverty_US.jpg",width="65%",title="")`
.center[Percentage of people in poverty by County: 2015-2019. Source: American Community Survey 2015-2019, 5-Year Data Release.]
]

.pull-right[
- This figure is an example of a **choropleth map**, which uses shades of color (or grey scale) to classify the values of the variable that we are mapping into classes.
`r vspace("20px")`
- From the choropleth map we know which areas are adjacent which other areas. The relationship between areal units is characterized in terms of .red[adjacency].
`r vspace("20px")`
- The *sites* $\boldsymbol{s} \in \mathcal{D}$ in this case are actually the polygons themselves. 
]

---

# Example of areal data [2]

`r include_fig("Italy_Covid_March2020.jpg",width="38%",title="")`

.center[Map of the percent excess mortality for the 107 Italian provinces during the first wave of Covid-19 pandemic. Epidemiological week 18-24 March, 2020; males.]

---

# Example of regular lattice data [3]

`r include_fig("Getis-Ord.jpg",width="40%",title="")`

.center[Regular lattice: Getis-Ord remote sensing example data (from package `spdep`).]


---

# Example of geostatistical data [1]

`r include_fig("Wind_Temp_StationsUS.jpg",width="45%",title="")`

.center[Map of wind and temperature stations in US (2019).]

`r vspace("20px")`

The data are gathered at a discrete set of points in an region of interest $(\mathcal{D})$, with the aim of understanding
the behaviour of an unobserved, spatially continuous phenomenon that exists throughout that region and could, in principle, be observed at any point in $\mathcal{D}$.

---

# Example of geostatistical data [2]
.center[Average air temperature in degree Celsius (March-November 2018)]
.pull-left[
`r include_fig("Rplot_Temp_Dry2018.jpeg",width="80%",title="")`

.center[Observed]
]

.pull-right[
`r include_fig("Rplot_Temp_Pred_Dry2018.jpeg",width="57%",title="")`

.center[Predicted]
]


`r vspace("20px")`

We can reconstruct a surface from the finite set of observations taken at a finite number of spatial locations.

---

# Examples of point pattern data [1]

`r include_fig("colera.jpg",width="40%",title="")`
.center[John Snow's map of the 1854 London cholera outbreak]
`r vspace("10px")`
- In 1854, cholera hit the city of London. No one knew where the disease started. So, British physician John Snow started mapping the outbreak.
- It wasnâ€™t just the disease. But he also mapped out roads, property boundaries, and water lines.
- When he added these features to a map, something interesting happened. He noticed that cholera cases were only along one water line. This was a breakthrough that connected geography to public health safety.
- The question of primary interest is whether, and if so where and when, statistically unusual local concentrations of cases occur.

---

# Examples of point pattern data [2]

`r include_fig("Earthquakes_Italy.jpg",width="38%",title="")`

.center[Location of earthquakes in Italy 1900-2017 (moment magnitude scale).]
`r vspace("10px")`
Other examples in which points are the location of an .red[event] of interest:
- Location of crimes
- Location of trees


---

# Data we will work with
In this course, we will work with:
`r vspace("20px")`

- Areal or lattice data
`r vspace("20px")`

- Geostatistical or spatial-referenced data

---

name: spatialR
  
`r vspace("250px")`

.myblue[.center[.huge[
**Spatial Data in R**]]]

---


# Spatial data in R: Vectors

The are two fundamental distinctions: spatial .red[vector] data and .red[raster].

- .red[Vector] represents the world using .red[points], .red[lines] and .red[polygons] or combinations of those, where:
`r vspace("20px")`
- *Point*, is a single point location, such as a geocoded address or a temperature sensor or the location of a bus stop;
`r vspace("20px")`
- *Line*, is a set of ordered points, connected by straight line segments such as route travel or connections between locations;
`r vspace("20px")`
- *Polygon*, is an area, marked by one or more enclosing lines such as local authority districts or census tracts.

---

Simple features, `sf` package `r Citet(bibfile,"Pebesma2018")`, support 18 geometry types. Of these, 7 are used in the vast majority of geographic research:

`r include_fig("Features_supported_by_sf.jpg", width="40%",title="")`

Core geometry types supported by the R package sf. Source: `r Citet(bibfile,"Lovelace2019")`, Section 2.2.

---

# Spatial data in R: Rasters

- .red[Raster]: typically divides the surface into cells (also called pixels) of constant size. The cell of one raster layer can only hold a single value, which might be numeric or categorical.

`r vspace("20px")`


- Examples of continuous and categorical raster data. 

`r include_fig("Raster_data.jpg", width="60%",title="")`

.center[Source: `r Citet(bibfile,"Lovelace2019")`, Section 2.3.]

---

# Some useful R packages 

-   `sf`, which is a recently developed package for spatial vector data (points, lines, polygons etc.) and combines the functionality of three previous packages `sp`, `rgeos` and `rgdal`. It refers to a formal standard that describes how objects in the real world can be represented in computers, with emphasis on the spatial geometry of these objects
`r vspace("10px")`
- `sp`, which precedes `sf`, and with the `rgdal` and `rgeos` package, it created a powerful tool to works with spatial data. However, `rgdal`, `rgeos`, and `maptools`
will be supported only until late 2023. `sp` was first release on CRAN in 2005 and provides classes and methods to create points, lines, polygons, and grids and to operate on them. Many R packages still depends on the `sp` package
`r vspace("10px")`
- `spdep`, which includes functions and tests for evaluating spatial patterns and autocorrelation
`r vspace("10px")`
- `terra` is is a successor of the `raster` package package. It contains classes and methods representing raster objects (but it has also its own vector data classes). It allows raster data to be loaded, processed and saved.
`r vspace("10px")`
- The `stars` package contains classes and methods representing spatio-temporal data (raster and vector data cubes)
`r vspace("10px")`
- `tidyverse`, which is a coherent system of packages for data manipulation, exploration and visualization
`r vspace("10px")`
- `ggplot2`, `tmap`, `leaflet`, `mapview` and `gganimate` for visualization and maps

---

# `sp` and `sf`

Many spatial R packages still depends on the `sp`, thus it is important to know how to convert `sp` to and from `sf` objects

```{r eval=FALSE, echo=TRUE, include=TRUE}
library(spData); library(sf); library(tidyverse)

# world is a sf object containing a world map data
# from Natural Earth with a few variables from World Bank
world = st_read(system.file("shapes/world.gpkg", package="spData"))
plot(world["pop"])                # plot world population

world_sp = as(world, "Spatial")  # from sf to sp object
class(world_sp)                   # "SpatialPolygonsDataFrame"

world_sf = st_as_sf(world_sp)    # from sp to sf object
class(world_sf)                   # "sf"  "data.frame"
```

`r include_fig("World_pop.jpeg", width="30%",title="")`

---

# `sp` and `sf`

`sf` works well with the `tidyverse` collection of R packages.

For example, functions can be combined using the pipe operator $\%>\%$ given that both packages are loaded

```{r eval=FALSE, include=TRUE, echo=TRUE}
# Select and plot information for a single attribute
world %>% select(lifeExp) %>% plot()
```

`r include_fig("LifeExp.jpeg", width="50%",title="")`

---

# `sp` and `sf`

`sf` object includes spatial metadata like the coordinate reference
system (CRS), which are stored in a list column.

We can extract and plot only the geometry with the function `st_geometry()`

```{r eval=FALSE, include=TRUE, echo=TRUE}
# Extract geometry
worlg_geo = st_geometry(world)
# Extract and plot out only the geometries
world %>% st_geometry() %>% plot()
```

`r include_fig("World_geom.jpeg", width="50%",title="")`
---

name: CRS
  
`r vspace("250px")`

.myblue[.center[.huge[
**Coordinate Reference Systems**]]]

---

# Coordinate Reference Systems (CRS)

- A CRS defines how the spatial elements of the data relate to the surface of the Earth. 

- There are two main types of CRS:

 1. .red[Geographic coordinate reference systems (GCRS)]: coordinate systems that identify any location on the Earth's surface using longitude and latitude, with units in decimal degrees or degrees.

 2. .red[Projected coordinate reference systems (PCRS)]: coordinate systems that provide various mechanisms to project maps of the Earth's ellipsoid shape onto a two-dimensional Cartesian coordinate plan. They are localized to minimize visual distortion in a particular region, with units on feet or meter. Projected coordinate systems are referred to as map projections.


`r include_fig("GCS_PCS.jpg", width="45%",title="")`

`r vspace("10px")`

.center[Source: https://www.esri.com/arcgis-blog/products/arcgis-pro/mapping/gcs_vs_pcs/]

---
# GCRS [1]

Geographic CRS refers to a point on the Earth by its latitude and longitude values, which are angles measured from the Earth's center to a point on the Earth's surface.

- The .blue[latitude] of a point on Earth's surface is the angle between the equatorial plane and the line that passes through that point and the center of the Earth. Latitude values are measured relative to the equator (0 degrees) and range from -90 degrees at the south pole to 90 degrees at the north pole. 

- The .blue[longitude] of a point on the Earthâ€™s surface is the angle west or east of the prime meridian to another meridian that passes through that point. Longitude values range from -180 degrees when running west to 180 degrees when running east.

`r include_fig("LongLat3.jpg", width="25%",title="")`

`r vspace("15px")`

.center[Source: https://annefou.github.io/metos_python/03-crs_proj/]


---
# GCRS [2]

- Obviously we cannot actually measure these angles, but we can estimate them. To do so, we need a model of the shape of the Earth. Such a model is called as the .red[datum].

- Datum contains information on what **ellipsoid** is used to approximate the Earth's shape and the relationship between the coordinate system and location on the Earth's surface; it also describes the origin of a coordinate system.

- There are two types of datum: geocentric and local

`r include_fig("datum.jpg", width="43%",title="")`

.center[Source: `r Citet(bibfile,"Lovelace2019")`, Section 2.4.]

---
# PCRS [1]

- Projected CRS are based on a GCRS and rely on map projections to convert the three-dimensional surface of the Earth into $x$ and $y$ values.

- The transition leads to some distortions: there is not one best projection. Some projections can be used for a map of the whole world; other projections are appropriate for small areas only.

- There are three main projection types: conic, cylindrical, and planar:

`r include_fig("Proj_CRS.jpg", width="40%",title="")`

`r vspace("15px")`

.center[Source: https://www.earthdatascience.org/courses/earth-analytics/spatial-data-r/geographic-vs-projected-coordinate-reference-systems-UTM/]

---

# PCRS [2]

- Projected CRS is optimized to best represent the shape, and/or
the rotation, and/or the area of features in a data set.

- There is not a single system that does a great job at optimizing all
these elements: shape, rotation and area.

`r include_fig("PCRS.jpg", width="50%",title="")`

.center[Source: https://ihatecoordinatesystems.com/]

`r vspace("35px")`

A funny and explanatory YouTube video on the trade off between GCRS and PCRS is at this link: https://www.youtube.com/watch?v=kIID5FDi2JQ

---
# Re-projecting

Re-projecting is the process of changing the representation of locations from one CRS to another. When should data be transformed?

- The projections of locations on the Earth into a two-dimensional plane are distortions, the projection that is best for an application may be different from the projection associated with the data we import. In these cases, data can be re-projected.

- Another case is when two objects with different CRSs must be compared or combined. Thus, in the case of dealing with multiple data, re-projection permits to transform all data to a common CRS.

- In R, to transform data to a different projection, we can use
  `st_transform()` function of the `sf` package.

---
# CRS in R (before 2020)

- Spatial R packages support a wide range of CRSs and they use the `PROJ` library to perform conversions between cartographic projections. 


- Before 2020, there are two ways of defining a CRS:

  - the .blue[proj4string] definition, which specifies attributes such as the projection, the ellipsoid and the datum, for example the WGS84 longitude and latitude projection is specified as:
$+proj=longlat +ellps=WGS84 +datum=WGS84 +no\_defs$
 
  - the .blue[EPSG] numeric code (EPSG stands for European Petroleum Survey Group). The code refers to only one, well-defined coordinate reference system, for example the EPSG code of the WGS84 projection is 4326 (Note that the EPSG code could not be available for a particular coordinate system; https://spatialreference.org/ref/epsg/)


---
# CRS in R (after 2020)

- There are new developments at level of `PROJ` (https://proj.org/), and shift from `proj4string` to the `OGC WKT2` representation (OGC stands for Open Geospatial Consortium, and WKT stands for Well-known Text formats) 


- The CRS is represented by:
 
   - a set of mathematical rules for specifying how coordinates are to be assigned to points;
 
   - a set of parameters defining the position of the origin, the scale, and the orientation of a coordinate system (datum)

- There is capability of direct transformations from CRS to CRS

- There is capability of time-dependent transformations (previously, static reference frames with no support for time-dependent datum, but on Earth, everything is moving, up to 80 mm/year!)

- The use of `proj4string` is discouraged (some `proj4string` string elements are not longer supported; also only three ellipsoids can be used). `proj4string` still can be used for coordinate operations (transformations between CRS).

- In `sf`, we can retrieve the CRS of an object using `st_crs()`

---
# Example
```{r echo=TRUE, eval=FALSE}
library(spData)
library(sf)
# Extract the CRS information from the sf object nz (New Zealand)
st_crs(nz) # here EPSG:2193

# Re-project
nz_wgs = st_transform(nz, 4326)
st_crs(nz_wgs) # now EPSG:4326
# Extract the CRS information from the sf object world
st_crs(world) #EPSG:4326

# Re-project using the CRS of the sf object world
nz_wgs = st_transform(nz, st_crs(world))
st_crs(nz_wgs)

# Remove the CRS from nz_wgs and plot the result
nz_wgs_NULL_crs = st_set_crs(nz_wgs, NA)

# Plots
par(mfrow = c(1, 3))
plot(st_geometry(nz))
plot(st_geometry(nz_wgs))
plot(st_geometry(nz_wgs_NULL_crs))
```

---
# Example

`r vspace("30px")`

`r include_fig("NZ.jpg", width="70%",title="")`

---
# References

```{r refs, echo=FALSE, results="asis"}
PrintBibliography(bibfile,.opts=list(max.names=3))
```
