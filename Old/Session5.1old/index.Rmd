---
title: "Session 5.1: spatio-temporal model for geostatistical data"
params: 
   conference: "Spatial and Spatio-Temporal Bayesian Models with `R-INLA`"
   location: "University of SÃ£o Paulo"
   date: 30 September 2022
   short_title: "Spatial and Spatio-Temporal Bayesian Models with `R-INLA`"

output:
  xaringan::moon_reader: 
    includes: 
       in_header: "assets/latex_macros.html" 
       # This line adds a logo based on the format selected in the file 'assets/include_logo.html'
       # NB: the actual options (eg placement of the logo and actual logo file) can be changed there
       after_body: "assets/insert-logo.html"
    seal: false
    yolo: no
    lib_dir: libs
    nature:
      beforeInit: ["https://platform.twitter.com/widgets.js"]
      navigation:
        scroll: false # disable slide transitions by scrolling
      highlightStyle: github
      highlightLines: yes
      countIncrementalSlides: no
      ratio: '16:9'
      titleSlideClass:
      - center
      - middle
    self_contained: false 
    css:
    - "assets/beamer.css"
---

```{r echo=F,message=FALSE,warning=FALSE,comment=NA}
# Sources the R file with all the relevant setup and commands
source("assets/setup.R")

# Stuff from 'xaringanExtra' (https://pkg.garrickadenbuie.com/xaringanExtra)
# This allows the use of panels (from 'xaringanExtra')
xaringanExtra::use_panelset()
# This allows to copy code from the slides directly
#xaringanExtra::use_clipboard()
# This freezes the frame for when there's a gif included
#xaringanExtra::use_freezeframe()

# Defines the path to the file with the .bib entries (in case there are references)
#bibfile=ReadBib("~/Dropbox/Lavori condivisi/2015_Book/ShortCourse/VIBASS/Biblio.bib",check = FALSE)

bibfile=ReadBib("~/Dropbox/Books/INLABook/ShortCourse/VIBASS/Biblio.bib",check = FALSE)

#bibfile=ReadBib("C:/Users/Monica/Dropbox/VIBASS/Biblio.bib",check = FALSE)
```

class: title-slide

# `r rmarkdown::metadata$title``r vspace("10px")` `r rmarkdown::metadata$subtitle`

## `r rmarkdown::metadata$author`

### `r rmarkdown::metadata$institute`    

### `r rmarkdown::metadata$params$conference`, `r rmarkdown::metadata$params$location` 

<!-- Can also separate the various components of the extra argument 'params', eg as in 
### `r paste(rmarkdown::metadata$params, collapse=", ")`
-->

`r ifelse(is.null(rmarkdown::metadata$params$date),format(Sys.Date(),"%e %B %Y"),rmarkdown::metadata$params$date)`



---

layout: true  

.my-footer[ 
.alignleft[ 
&nbsp; &copy; Marta Blangiardo | Monica Pirani
]
.aligncenter[
`r rmarkdown::metadata$params$short_title` 
]
.alignright[
`r rmarkdown::metadata$params$conference`, `r short_date` 
]
] 

```{css,echo=FALSE, eval=FALSE}
.red {
  color: red;
}
.blue {
  color: 0.14 0.34 0.55;
}

.content-box-blue { background-color: #F0F8FF; }

}
```

```{css, echo=FALSE}
.scrollable {
  height: 80%;
  overflow-y: auto;
} 
```

---

# Learning Objectives

At the end of this session you should be able to:

`r vspace("20px")`

- know the definition of spatio-temporal process in the geostatistics framework;


`r vspace("20px")`


- use `inlabru` for implementing a (separable) space-time geostatistical model.


`r vspace("30px")`


The topics treated in this lecture can be found in **Section 7.2** of the INLA book.  

---

# Outline 

`r vspace("30px")`

1\. [Spatio-temporal processes + a space-time hierarchical model for air pollution](#stprocess)

`r vspace("30px")`

2\. [Implementation of a spatio-temporal process using `inlabru`](#stinlabru)


---

name: stprocess
  
`r vspace("250px")`

.myblue[.center[.huge[
**Spatio-temporal processes + a space-time hierarchical model for air pollution**]]]



---

# Spatio-temporal processes

-  The concept of spatial process can be extended to the spatio-temporal case including a time dimension. The data are then defined by a process 
$\{y(s,t), (s,t) \in \mathcal D \subset \mathbb{R}^{2}\times \mathbb{R}\}$
and are observed at $n$ spatial locations and at $T$  time points. 

--

`r vspace("20px")`
- When spatio-temporal geostatistical data are considered, we need to define a valid .red[**spatio-temporal covariance function**] given by 
$$\mbox{Cov}\left(y(\bm s_i,t), y(\bm s_j,u)\right)=\mathcal {C}(y_{it},y_{ju})$$
--
`r vspace("20px")`

- If we assume .red[**stationarity in space and time**], the space-time covariance function can be written as a function of the spatial Euclidean distance $\Delta_{ij}=||\bm s_{i}-\bm s_{j}||$ and of the temporal lag $\Lambda_{tu}=|t-u|$ so that $\mbox{Cov}\left(y_{it}, y_{ju}\right)=\mathcal C(\Delta_{ij},\Lambda_{tu})$.

--
`r vspace("20px")`
-  If we assume .red[**separability**] the stationary space-time covariance function is decomposed into the product (or the sum) of a purely spatial and a purely temporal term: $$\mbox{Cov}\left(y_{it}, y_{ju}\right)=\mathcal{C}_1(\Delta_{ij})\mathcal{C}_2(\Lambda_{tu})$$

---

# Hierarchical spatio-temporal model for PM concentration

- We present a spatio-temporal model for particulate matter (PM10) concentration data measured daily (in $\mu g /m^3$). 

`r vspace("20px")`
- The data refer to Piemonte region (Italy) for the period from October 2005 to March 2006 (daily data).

`r vspace("20px")`
- **Main aims**:
`r vspace("10px")`
  - predict PM concentration in the considered continuous spatial domain, where no monitoring stations are displaced;
  `r vspace("10px")`
  - evaluate the effect of some covariates (e.g. wind speed, precipitation, temperature, emissions, altitude);
  `r vspace("10px")`
  - compute the probability of exceeding a specific threshold (e.g. $50$ $\mu g /m^3$ fixed by the European Community for health protection).

`r vspace("20px")`
-  The spatio-temporal model we specify here is widely adopted in the air quality literature thanks to its 
flexibility in modeling relevant covariates as well as correlation in space and time (see `r Citet(bibfile,"cameletti2013", "FIORAVANTI2021")`).

---

# Hierarchical spatio-temporal model for PM concentration


- We denote by $y_{it}$ the logarithm of PM10 concentrations measured at site $\bm s_i$, with $i=1,\ldots,n=24$, and day $t=1,\ldots,T=182$. 

`r vspace("20px")`
- The following distribution is assumed for the observations:
$$\color{blue}{y_{it}\sim \text{Normal}( \eta_{it},\sigma^2_e)}$$
where $\sigma^{2}_{e}$ is the variance of the measurement error defined by a Gaussian white-noise process, both serially and spatially uncorrelated.

--

`r vspace("20px")`
- The linear predictor is given by
$$\color{blue}{\eta_{it} = b_0+ \sum_{m=1}^M \beta_m x_{mi} + \omega_{it}}$$
where $b_0$  is the intercept and $\beta_1,\ldots,\beta_M$ are the linear effects related to meteorological and orographical covariates $\bm x_1,\ldots, \bm x_M$. 

---

# Hierarchical spatio-temporal model for PM concentration

- The term $\omega_{it}$ refers to the **latent spatio-temporal process** (i.e. the true unobserved level of pollution) which changes in time with first order autoregressive dynamics and spatially correlated innovations:

$$\color{blue}{\omega_{it} = a\omega_{i(t-1)}+\xi_{it}}$$
with $t=2,\ldots,T$, $|a|<1$, $\omega_{i1}\sim\text{Normal}\left(0,\sigma^2/ (1-a^2)\right)$.

--

`r vspace("20px")`
- The term $\xi_{it}$ is a zero-mean **Gaussian field**, assumed to be **temporally independent** and characterized by the following spatio-temporal covariance function:

$$\text{Cov}\left(\xi_{it},\xi_{ju}\right) =\left\{
\begin{array}[c]{ccc}%
0 &  &  \text{if} \qquad t\neq u\\
\text{Cov}(\xi_i,\xi_j) && \text{if} \qquad t=u
\end{array}
\right.$$

for $i\neq j$, where $\text{Cov}(\xi_i,\xi_j)$ is given by Mat&eacute;rn spatial covariance function.

`r vspace("20px")`
- This model is characterized by a **separable spatio-temporal covariance** as it can be rewritten as the product of a purely spatial and a purely temporal covariance function (see `r Citet(bibfile,"cameletti2011")`).

---

# Hierarchical spatio-temporal model for PM concentration

- For each time point $\bm \xi_t \sim \text{Normal}(\bm 0, \bm\Sigma)$ and through the SPDE approach 
$$ \bm \xi_t \rightarrow \tilde{\bm \xi_t}\sim\text{Normal}(\bm 0,\bm Q^{-1}_S)$$
where the precision matrix $\bm Q_S$ comes from the SPDE representation. The matrix $\bm Q_S$  does not change in time - due to the serial independence hypothesis - and its dimension is given by the number of vertices of the domain triangulation.

--

`r vspace("20px")`
- The joint distribution of the $Tn$-dimensional GMRF $\bm\omega=(\bm\omega_1^\prime,\ldots,\bm\omega_T^\prime)^\prime$ is 
$$\bm\omega\sim\text{Normal}(\bm 0,\bm Q^{-1})$$
with $\bm Q=\bm Q_T \otimes \bm Q_S$, where $\otimes$ denotes the Kronecker product and $\bm Q_T$ is the $T$-dimensional precision matrix of the AR(1) process.

`r vspace("20px")`
- For the considered model the latent process is given by $\bm \theta=\{\bm \omega, b_0, \beta_1,\ldots, \beta_M\}$ while the hyperparameter vector is $\psi=(\sigma^2_e, a, \sigma^2, r)$.

---

name: stinlabru
  
`r vspace("250px")`

.myblue[.center[.huge[
**Implementation of a spatio-temporal process using `inlabru`**]]]


---

# Piemonte data

The data are **PM10 concentrations** in 24 monitoring stations in Piemonte region in Italy for a period of 182 days from 2005-10-01 to 2006-03-31.

.panelset[
.panel[.panel-name[Data]
```{r, echo=F}
op <- options("width"=250) # large number to trick head, otherwise see next 
```

```{r}
df = readRDS("./data/Piemonte_Data.rds")
class(df)
head(df)
# select only the first 50 days for reducing the computational load
df = df[df$time <= 50,]
```
```{r, echo=F}
options(op) # set options back to default
```
]
.panel[.panel-name[Boundary]
.pull-left[
```{r}
library(tidyverse)
library(inlabru)
border = readRDS("./data/Piemonte_Border.rds")
class(border)
```
```{r piemonteborder, eval=F}
ggplot()+
  gg(border) +
  coord_equal()
```
]
.pull-right[
```{r bordermap,ref.label="piemonteborder", echo=F, fig.height=2, out.width="100%"}
```
]
]
]

---

# PM10 data

.pull-left[
We plot PM10 concentrations measured in the 24 monitoring stations in the first **3 days** of the time series.

```{r mapPM10_3days, eval=F}
library(tidyverse)
library(viridis)

df %>% 
  filter(time<=3) %>%
  ggplot() + 
  geom_point(aes(UTMX, UTMY, color = PM10), size = 2)+
  facet_wrap(.~ Date, ncol = 2, nrow = 2) +
  scale_color_viridis() +
  coord_equal() +
  gg(border)
```
]
.pull-right[
```{r mapPM10_3days_out, echo=F, ref.label="mapPM10_3days", fig.height=4, out.width="100%"}
```
]

---

# Create the mesh and the SPDE model
For the example we choose a quite rough mesh (starting from the monitoring stations):

.pull-left[
```{r}
library(INLA)
mesh = inla.mesh.2d(loc = cbind(df$UTMX, df$UTMY),
                    offset = c(20, 40),
                    max.edge = c(30, 50))
```
```{r, eval=F}
ggplot() +
  gg(mesh) +
  geom_point(data = df, aes(UTMX, UTMY)) + 
  gg(border)
```
Given the mesh, it is now possible to create the SPDE model using the `inla.spde2.matern` function:

```{r}
spde = inla.spde2.matern(mesh = mesh) 
spde$n.spde #n. of mesh vertices
```


]
.pull-right[
```{r mesh, echo=F, fig.dim=c(4.5, 4), out.width="100%"}
ggplot() +
  gg(mesh) +
  geom_point(data = df, aes(UTMX, UTMY)) + 
  gg(border)
```
]

---

# Define the model components using `inlabru`

We run here the model using `inlabru`. If you are interested in the alternative version based on the `inla.stack` approach, see Section 7.2 of the INLA book. 
`r vspace("20px")`

We first transform the `df` data frame into a **spatial object** (`SpatialPointsDataFrame`)
```{r}
coordinates(df) = c("UTMX","UTMY")
class(df)
```

and then define the model **components**

```{r}
cmp  = logPM10 ~ Intercept(1) + 
  SPDE(coordinates, model = spde,
       group = time, control.group = list(model = "ar1")) + #<<
  A + #dem(A, model = "linear") +  
  TEMP #temp(TEMP, model = "linear")
```

Using the options `group` and `control.group` we specify that at each time point the spatial locations are linked by the `spde` model object, while across time the process evolves according to an AR(1) dynamics.

---

# Fit the space-time model using `inlabru`

We then define the **likelihood**
```{r}
lik = like(formula = logPM10 ~ Intercept + SPDE + A + TEMP,
           family = "gaussian",
           data = df)
```

and finally run the model with `bru`
```{r,eval=F}
fit = bru(cmp, lik)
```
```{r, eval=F, echo=F}
saveRDS(fit,"./data/fit.rds")
```
```{r,echo=F}
fit = readRDS("./data/fit.rds")
```
```{r}
fit$summary.fixed[,c("mean","0.025quant","0.975quant")]
```

---

# Prediction at the station locations
We are interested in predicting PM10 concentrations (log concentrations) at the monitoring station locations. As introduced in Section 4.2, we will use the `predict` function:

.panelset[
.panel[.panel-name[Compute predictions]
`r vspace("20px")`
```{r, echo=F, eval=F}
op <- options("width"=150) # large number to trick head, otherwise see next 
```
  ```{r}
pred_at_station = predict(fit, df, ~ Intercept + SPDE + A + TEMP, n.samples = 1000)
head(pred_at_station)
```
```{r, echo=F, eval=F}
options(op) # set options back to default
```
]
.panel[.panel-name[Plot predictions]
.pull-left[
Select 6 stations
```{r}
sel = c(1, 7, 10, 19, 23, 24)
```

and plot the observed/predicted time series: 
```{r predstations,eval=F}
as.data.frame(pred_at_station) %>%
  dplyr::filter(Station.ID %in% sel) %>% 
  ggplot() + 
  geom_line(aes(time, logPM10, group = Station.ID), color = "red") +
  geom_line(aes(time, mean, group = Station.ID)) +
  geom_ribbon(aes(time, ymin = q0.025, ymax = q0.975, group = Station.ID), alpha = 0.5) +
  facet_wrap(.~Station.ID)
```
]
.pull-right[
```{r predstationsout,eval=T,echo=F, ref.label="predstations"}
```
]
]
]

---

# Prediction at the grid locations

We want to predict the concentration (log concentration) of PM10 for the locations in the Piemonte grid and for the first 3 days. To do this we need the values of the altitude and temperature for every point of interest in both space (regular grid) and time.

.panelset[
  .panel[.panel-name[Grid data]
```{r}
covariate_grid = readRDS("./data/covariate_grid.rds")
class(covariate_grid)
head(covariate_grid@data)
```

Mask the grid using the Piemonte `border` created before:
```{r}
covariate_grid = covariate_grid[!is.na(sp::over(covariate_grid, border)),]
dim(covariate_grid@data)
```
]

.panel[.panel-name[Altitude]
.pull-left[
```{r mapAgrid, echo=T, eval=F}
ggplot() + 
gg(covariate_grid, aes(fill=A)) + 
gg(border) +
coord_equal() + 
scale_fill_viridis()
```
]
.pull-right[
```{r mapAgridout,echo=F, ref.label="mapAgrid", out.width="100%", fig.height=2}
```
]
]

.panel[.panel-name[Temperature]
.pull-left[
```{r mapTempgrid, echo=T, eval=F}
ggplot() + 
gg(covariate_grid, aes(fill=TEMP)) +
facet_wrap(~ time) +
gg(border) +
coord_equal() +
scale_fill_viridis()
```
]
.pull-right[
```{r mapTempgridout,echo=F, ref.label="mapTempgrid", fig.dim=c(6, 4), out.width="100%"}
```
]
]
]

---

# Prediction at the grid locations

- We sample from the fitted model in order to inspect the PM10 field. As described in Section 4.2, the function `predict` is used for sampling from the posterior predictive distributions and computing posterior summary statistics. In this case we use the space-time grid (`covariate_grid`) introduced before. 


```{r}
pred = predict(fit, covariate_grid, 
               ~ Intercept + SPDE + A + TEMP,
               seed = 2, n.samples = 1000)
head(pred@data)
```

---

# And finally the daily maps for PM10 (mean) concentrations!

```{r mapsgridout, out.width="100%", fig.height=2}
ggplot() + 
  gg(pred, aes(UTMX_km, UTMY_km, fill = mean))  +
  facet_wrap(.~ time) + 
  scale_fill_viridis() + coord_equal() + gg(border)
```

---

# Maps for the exceedance probability

.pull-left[
With `inlabru predict()` function, it is also very easy to compute the posterior probability of exceeding the $50$ $\mu g /m^3$ threshold:

```{r}
predprob = predict(fit, covariate_grid, 
               ~ (Intercept + SPDE + A + TEMP) > log(50),
               seed = 2, n.samples = 500)
```
```{r postprobmap, eval = F, echo=T, fig.height=3}
ggplot() + 
  gg(predprob, aes(UTMX_km, UTMY_km, fill = mean))  +
  facet_wrap(.~ time, ncol = 2, nrow = 2) + 
  scale_fill_viridis() + coord_equal() + gg(border)
```
]
.pull-right[
```{r postprobmapout,echo=F, ref.label="postprobmap", fig.dim=c(6, 4), out.width="100%", out.height="100%"}
```
]

---

# References

```{r refs, echo=FALSE, results="asis"}
PrintBibliography(bibfile,.opts=list(max.names=3))
```

