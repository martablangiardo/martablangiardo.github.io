---
title: "Practical 8b - INLA-SPDE for geostatistical data: Temperature in Croatia "
author: "Bayesian modelling for spatial and spatio-temporal data"
header-includes:
    - \usepackage{bm}
output:
  html_document:
    toc: true
    toc_float: true
bibliography: biblio.bib
---
  
\pagenumbering{gobble} 
\pagenumbering{arabic} 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE, fig.align = "center", class.source='klippy')
```
```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy(position = c('top', 'right'),color = 'darkred',
               tooltip_message = 'Click to copy', tooltip_success = 'Done')
```

## 1. Introduction 
In this practical we will make use of INLA-SPDE [@Lindgren2011] for implementing a spatial model and performing spatial prediction. We will use a dataset related to **daily temperature measurements** automatically collected at 123 meteorological stations in Croatia on 19th July 2006. Moreover, information about elevation (in mt) and distance in km from the coastline are available on a regular grid. 

In the following we will implement a geostatistical model with temperature as response variable, and elevation and distance as covariates.

The following packages are required:
```{r, class.source='klippy'}
library(tidyverse)
library(INLA)
library(inlabru)
library(viridis) #for colors
```

The data are included in the workspace `temperature.croatia.Rdata` which can be loaded in `R` via 
```{r}
# Remove old objects
remove(list=ls())
# Remember to set the correct working directory
load("temperature.croatia.Rdata")
ls()
```


## 2. Explore and analyse the data 

The workspace contains now two `data.frame` objects: 

1. The first is named `stations_data` and contains information about the 123 meteorological stations. Exploring the data
```{r}
glimpse(stations_data)
```

we see that the it includes 10 variables. The important variables for the application are: 

- elevation (`HRdem`)
- latitude (`Lat`) 
- longitude (`Lon`)
- the temperature response variable `MDTEMP`

2. The second data frame is named `grid_cov` and contains the covariate information for a regular grid of 1250 points (25 $\times$ 50):
```{r}
glimpse(grid_cov)
```

The regular grid (gray points) together with the monitor stations (red points) are represented in the following plot:
```{r}
ggplot()+
  geom_point(data = grid_cov, aes(Lon,Lat), col = "gray") +
  geom_point(data = stations_data, aes(Lon,Lat), col = "red", size = 2) +
  theme_bw()
```

We plot also the distribution of the response variable `MDTEMP` (histogram + density function) measured in the monitoring stations:
```{r}
stations_data %>% 
  ggplot() +
  geom_histogram(aes(MDTEMP, after_stat(density)),bins = 13, alpha=0.5) +
  geom_density(aes(MDTEMP)) 
```

Looking at the plot  and using the **Shapiro-Wilk Normality test**
```{r}
shapiro.test(stations_data$MDTEMP)
```
we can conclude that the response variable is approximately Normal.

It can also be useful to plot the values of the covariate `HRdem` (elevation) for both the monitoring station sites and the points of the regular grid.

```{r}
stations_data %>% 
  ggplot() +
  geom_point(aes(Lon, Lat, col = HRdem), size = 2) +
  scale_color_viridis()
```

```{r}
grid_cov %>% 
  ggplot() +
  geom_raster(aes(Lon, Lat, fill=HRdem)) +
  scale_fill_viridis()
```



## 3. Model

As shown in Lecture 3.2, we assume the following spatial model
\[
y_i \sim \text{Normal}(\eta_i, \sigma^2_e) \qquad i=1,\ldots, 123
\]
where $\sigma^{2}_e$ is the variance of the zero mean measurement error $e_i$ which is supposed to be normally distributed and independent on $e_{j}$ for each $i\neq j$. The linear predictor is given by
\[
\eta_i = \beta_0+ \beta_1 \texttt{HRdem}_i + \xi_i
\]
and includes an intercept $\beta_0$, a linear effect $\beta_1$ of elevation and the spatial random effect $\xi_i$ which is a priori a Matern GF.



## 4. Mesh construction

The first step for implementing the SPDE approach is the definition of the mesh. Since in this case the Croatia borders are quite irregular we use the new `inla.nonconvex.hull` function:
```{r}
bnd = inla.nonconvex.hull(cbind(stations_data$Lon,stations_data$Lat), convex=0.25)

croatia.mesh = inla.mesh.2d(loc = cbind(stations_data$Lon,
                                       stations_data$Lat),
                          boundary = bnd,
                          offset = c(1, 2),
                          max.edge = c(3, 8),
                          cutoff = 0.3)
```


Now, plot the mesh, using (i) the standard code, (ii) the `inlabru` package function `gg` (using `ggplot` style)
```{r, echo=FALSE, eval=FALSE}
# plot with standard code
plot(croatia.mesh,asp=1)
points(stations_data$Lon, stations_data$Lat, pch=21, cex=1.2, bg="white",col=1)
```

```{r, echo=FALSE, eval=FALSE}
# plot with inlabru 
ggplot() + 
  gg(croatia.mesh) +
  geom_point(data = stations_data, aes(Lon, Lat))
```


## 5. Model fitting 

We use `R-INLA` and the `inla.stack` function to estimate the parameters of the given model where $\{\mathbf \xi,\beta_0,\beta_1\}$ and the hyperparameter vector contains $\sigma^2_e$, the spatial variance $\sigma^2$ and the spatial range $r$. 


1. We start by creating the SPDE model object. Call the SPDE model as `spde` and check the number of vertices
```{r, echo=FALSE, eval=TRUE}
spde = inla.spde2.matern(mesh = croatia.mesh)
```
 
```{r, echo=FALSE, eval=FALSE, include=FALSE}
spde$n.spde
```

2. Then define the projector matrix $A$ and the `inla.stack` object for the **estimation** part. 
Call the projection matrix as `A.est`, and the stack for the estimation as `stack.est` (call the tag as `tag="est"`)
```{r, echo=FALSE, eval=TRUE}
A.est = inla.spde.make.A(croatia.mesh,
                         loc = as.matrix(cbind(stations_data$Lon,stations_data$Lat)))
dim(A.est)


stack.est = inla.stack(data = list(temp = stations_data$MDTEMP),
                       A = list(A.est, 1, 1),
                       effects = list(spatial.index = 1:spde$n.spde,
                                      Intercept = rep(1, nrow(stations_data)),
                                      HRdem = stations_data$HRdem), 
                       tag="est")
```

3. We define now the projector matrix $A$ and the `inla.stack` object for the **prediction** part considering the `grid_cov` regular grid.
Call the projection matrix as `A.pred`, and the stack for the estimation as `stack.pred` (call the tag as `tag="pred"`)
```{r, echo=FALSE, eval=TRUE}
A.pred = inla.spde.make.A(croatia.mesh,
                          loc = cbind(grid_cov$Lon,grid_cov$Lat))

stack.pred = inla.stack(data = list(temp = NA), 
                        A = list(A.pred, 1, 1),
                        effects = list(spatial.index = 1:spde$n.spde,
                                       Intercept = rep(1, nrow(grid_cov)),
                                       HRdem = grid_cov$HRdem),
                        tag = "pred")
```

4. Finally join all the `inla.stack` objects (call it as `fullstack`), define the `formula` and run the `inla` function (including also the computation of DIC), and call the output object as `output`
```{r, echo=FALSE, eval=TRUE}
fullstack = inla.stack(stack.est, stack.pred)

formula = temp ~ -1 + Intercept + HRdem + f(spatial.index, model = spde)

output = inla(formula,
       data = inla.stack.data(fullstack, spde = spde),
       family = "gaussian",
       control.predictor = list(A = inla.stack.A(fullstack), compute = TRUE),
       control.compute = list(dic = TRUE))
```


* Extract now the posterior distribution of the **fixed effects** and comment the results on elevation
```{r, echo=FALSE, eval=TRUE}
output$summary.fixed
```


* Plot the marginal posterior of intercept and elevation:
```{r, echo=TRUE, eval=FALSE}
inla.smarginal(output$marginals.fixed$Intercept) %>% 
  dplyr::bind_rows() %>%  #from list to data frame
  ggplot() +
  geom_line(aes(x,y)) +
  ggtitle("Intercept")

inla.smarginal(output$marginals.fixed$HRdem) %>% 
  dplyr::bind_rows() %>%  #from list to data frame
  ggplot() +
  geom_line(aes(x,y)) +
  ggtitle("Elevation")
```


* Then compute the posterior summaries (mean, standard deviation and 0.025, 0.5, 0.975 quantiles) about the Gaussian observation variance $\sigma^2_e$ by transforming the precision posterior distribution with `inla.tmarginal`
```{r, echo=FALSE, eval=FALSE}
sigma2e_marg =
  inla.tmarginal(function(x) 1/x,
  output$marginals.hyperpar$"Precision for the Gaussian observations")

inla.zmarginal(sigma2e_marg)
```


* Extract the posterior summaries of the spatial parameters from the output by means of the `inla.spde2.result` function
```{r}
output.field = inla.spde2.result(inla = output, 
                                 name = "spatial.index",
                                 spde = spde,
                                 do.transf = TRUE)
```

Then we use the following code to retrieve the piece of information we need for the spatial variance and the range:
```{r}
var.nom.marg = output.field$marginals.variance.nominal[[1]]
inla.zmarginal(var.nom.marg)

range.nom.marg = output.field$marginals.range.nominal[[1]]
inla.zmarginal(range.nom.marg)
```


* Finally extract the DIC 
```{r, echo=FALSE, eval=FALSE}
output$dic$dic
```


## 6. Mapping spatial prediction 

We will now use the linear predictor ($\eta$) to create a map of the temperature mean field for the regular grid covering Croatia. To access information about the predictions at the target grid locations, we extract with the `inla.stack.index` function the corresponding data indexes from the full stack object using the corresponding tag (`pred`):

```{r}
index.pred = inla.stack.index(stack = fullstack, "pred")$data
```

Then we extract and save in `grid_cov` the posterior mean and sd of the linear predictor with 
```{r}
grid_cov$post.mean.pred = output$summary.linear.predictor[index.pred, "mean"]
grid_cov$post.sd.pred = output$summary.linear.predictor[index.pred, "sd"]
```

We finally plot the map of the posterior mean and standard deviation of the linear predictor: 
```{r, echo=TRUE, eval=FALSE}
grid_cov %>% 
  ggplot() +
  geom_raster(aes(Lon, Lat, fill = post.mean.pred)) +
  scale_fill_viridis() +
  ggtitle("Posterior mean") 

grid_cov %>% 
  ggplot() +
  geom_raster(aes(Lon, Lat, fill = post.sd.pred)) +
  scale_fill_viridis() +
  ggtitle("Posterior SD") 

```

# References
