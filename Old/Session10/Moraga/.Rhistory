remotes::install_github("geocompr/geocompkg",
upgrade = "ask", dependencies = TRUE, force = TRUE)
remotes::install_github("nowosad/spDataLarge")
warning()
warnings()
warnings()
remotes::install_github("nowosad/spDataLarge")
library(terra)
remotes::install_github("nowosad/spDataLarge")
library(spDataLarge)
remotes::install_github("jhelvy/renderthis", force=TRUE)
remotes::install_github('rstudio/chromote')
install.packages("webshot2")
library(renderthis)
library(webshot2)
library(xaringan)
# rmarkdown
install.packages("rmarkdown", dep = TRUE)
# xaringan
remotes::install_github('yihui/xaringan')
# xaringan
remotes::install_github('yihui/xaringan')
install.packages("cli")
install.packages("cli")
install.packages("cli")
install.packages("cli")
install.packages("cli")
library()
install.packages("cli")
library(devtools)
install.packages("cli")
install.packages("cli")
install.packages("cli")
remove.packages(xaringan)
remove.packages("rmarkdown")
remove.packages("xaringan")
remotes::install_github("mitchelloharawild/icons")
install.packages("tikzDevice")
install.packages("kableExtra")
install.packages("dplyr")
install.packages("shiny")
install.packages("RefManageR")
library()
remotes::install_github("gadenbuie/xaringanExtra")
install.packages("servr")
install.packages("kableExtra")
library(xaringan)
library(xaringanExtra)
.libPaths()
1500*3
150*4
600*3
4500+1800
4*130
520*3
6300+2500
10-8800
10000-8800
1500*2
150*4*2
3000+1200
52.4/10.1
52.4^2/10.1
5.18*5.18
26.8*10.1
(52.4*52.4)/10.1
52.4/1000
271.85/1000
knitr::opts_chunk$set(echo = TRUE)
library(gstat)
# We use Meuse dataset, which includes concentrations of zinc
# measured at 155 sampling sites within the Meuse River plain
data(meuse)
library(sp)
library(gstat)
# We use Meuse dataset, which includes concentrations of zinc
# measured at 155 sampling sites within the Meuse River plain
data(meuse)
# Transform the dataframe into a SpatialPointDataFrame
coordinates(meuse) = ~x+y # the function coordinates
# promotes the data.frame meuse
# into a SpatialPointsDataFrame
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
# Construct the variogram
meuse.vgm = variogram(log(zinc)~1, meuse) # we assume a constant trend for
# the variable log(zinc)
# Plot the experimental variogram
plot(meuse.vgm)
plot(meuse.vgm, plot.numbers = TRUE, pch = "+") # The numbers of points in the
# lag group used to compute the corresponding value of gamma(h)
# Fit a variogram model
model.1 = fit.variogram(meuse.vgm, vgm("Sph"))
plot(meuse.vgm, model=model.1)
# Look at the result of the fit
model.1
# We can also specify a set of models. In this case the best fitting is returned
model.2 = fit.variogram(meuse.vgm, vgm(c("Exp", "Sph")))
model.2 # here the spherical model with nugget=0.051, partial sill =0.591 and range=897 is chosen
# Specify theoretical variogram with its characteristics
model.final = fit.variogram(meuse.vgm, vgm(psill=0.59,"Sph",range=897,nugget=0.05))
plot(meuse.vgm, model=model.final)
# We use Meuse dataset, which includes concentrations of zinc
# measured at 155 sampling sites within the Meuse River plain
data(meuse)
View(meuse)
# Transform the dataframe into a SpatialPointDataFrame
coordinates(meuse) = ~x+y # the function coordinates
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
hist(meuse$zinc) # we see a strong right skew in the data, so we log-transform them
hist(meuse$zinc) # we see a strong right skew in the data, so we log-transform them
# Lagged scatter plot
hscat(log(zinc)~1, meuse,(0:9)*100) # the correlation is quite strong when the lag
# We use Meuse dataset, which includes concentrations of zinc
# measured at 155 sampling sites within the Meuse River plain
data(meuse)
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
# Transform the dataframe into a SpatialPointDataFrame
coordinates(meuse) = ~x+y # the function coordinates
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
hist(meuse$zinc) # we see a strong right skew in the data, so we log-transform them
# Lagged scatter plot
hscat(log(zinc)~1, meuse,(0:9)*100) # the correlation is quite strong when the lag
# Construct the variogram
meuse.vgm = variogram(log(zinc)~1, meuse) # we assume a constant trend for
# Plot the experimental variogram
plot(meuse.vgm)
plot(meuse.vgm, plot.numbers = TRUE, pch = "+") # The numbers of points in the
lot(meuse.vgm, plot.numbers = TRUE, pch = "+") #
plot(meuse.vgm, plot.numbers = TRUE, pch = "+") #
# Construct the variogram
meuse.vgm = variogram(log(zinc)~1, meuse) # we assume a constant trend for
plot(meuse.vgm, plot.numbers = TRUE, pch = "+") # The numbers of points in the
# Fit a variogram model
model.1 = fit.variogram(meuse.vgm, vgm("Sph"))
plot(meuse.vgm, model=model.1)
# Look at the result of the fit
model.1
model.final = fit.variogram(meuse.vgm, vgm(psill=0.59,"Sph",range=897,nugget=0.05))
plot(meuse.vgm, model=model.final)
View(meuse)
head(meuse)
# We use Meuse dataset, which includes concentrations of zinc
# measured at 155 sampling sites within the Meuse River plain
data(meuse)
head(meuse)
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
# Transform the dataframe into a SpatialPointDataFrame
# the function coordinates promotes the data.frame meuse into a SpatialPointsDataFrame
coordinates(meuse) = ~x+y
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
hist(meuse$zinc) # we see a strong right skew in the data, so we log-transform them
# Lagged scatter plot
hscat(log(zinc)~1, meuse,(0:9)*100) # the correlation is quite strong when the lag
# Construct the variogram
meuse.vgm = variogram(log(zinc)~1, meuse) # we assume a constant trend for
# Plot the experimental variogram
plot(meuse.vgm)
plot(meuse.vgm, plot.numbers = TRUE, pch = "+") # The numbers of points in the
# Fit a variogram model
model.1 = fit.variogram(meuse.vgm, vgm("Sph"))
plot(meuse.vgm, model=model.1)
# We can also specify a set of models. In this case the best fitting is returned
model.2 = fit.variogram(meuse.vgm, vgm(c("Exp", "Sph")))
model.2 # here the spherical model with nugget=0.051, partial sill =0.591 and range=897 is chosen
model.final = fit.variogram(meuse.vgm, vgm(psill=0.59,"Sph",range=897,nugget=0.05))
plot(meuse.vgm, model=model.final)
setwd("C:/Users/Monica/Dropbox/TEACHING/YEAR_2023/Advanced_Analytics_2023/Material/Session5.1/Moraga")
library(lwgeom)
library(raster)
m <- getData(name = "GADM", country = "Spain", level = 0)
plot(m)
#
library(sf)
library(dplyr)
m <- m %>%
st_as_sf() %>%
st_cast("POLYGON") %>%
mutate(area = st_area(.)) %>%
arrange(desc(area)) %>%
slice(1)
#
library(ggplot2)
ggplot(m) + geom_sf() + theme_bw()
m <- m %>% st_transform(25830)
ggplot(m) + geom_sf() + theme_bw() + coord_sf(datum = st_crs(m))
#### Read data
d <- read.csv("dataPM25.csv")
d <- d[, c(
"ReportingYear", "StationLocalId",
"SamplingPoint_Longitude",
"SamplingPoint_Latitude",
"AQValue"
)]
names(d) <- c("year", "id", "long", "lat", "value")
library(sf)
p = st_as_sf(data.frame(long = d$long, lat = d$lat),
coords = c("long", "lat"))
st_crs(p) = st_crs(4326)
p = p %>% st_transform(25830)
d[, c("x", "y")] = st_coordinates(p)
ind <- st_intersects(m, p)
d <- d[ind[[1]], ]
### project the data
p <- st_as_sf(data.frame(long = d$long, lat = d$lat),
coords = c("long", "lat"))
st_crs(p) <- st_crs(4326)
p <- p %>% st_transform(25830)
d[, c("x", "y")] <- st_coordinates(p)
ind <- st_intersects(m, p)
d <- d[ind[[1]], ]
ggplot(m) + geom_sf() + coord_sf(datum = st_crs(m)) +
geom_point(data = d, aes(x = x, y = y)) + theme_bw()
# plot 3 years of data
library(viridis)
ggplot(m) + geom_sf() + coord_sf(datum = NA) +
geom_point(
data = d, aes(x = x, y = y, color = value),
size = 2
) +
labs(x = "", y = "") +
scale_color_viridis() +
facet_wrap(~year) +
theme_bw()
### Models ####
library(INLA)
coo <- cbind(d$x, d$y)
bnd <- inla.nonconvex.hull(st_coordinates(m)[, 1:2])
mesh <- inla.mesh.2d(
loc = coo, boundary = bnd,
max.edge = c(100000, 200000), cutoff = 1000
)
plot(mesh)
points(coo, col = "red")
# spde
spde <- inla.spde2.pcmatern(
mesh = mesh, alpha = 2, constr = TRUE,
prior.range = c(10000, 0.01), # P(range < 10000) = 0.01
prior.sigma = c(3, 0.01) # P(sigma > 3) = 0.01
)
timesn <- length(unique(d$year))
indexs <- inla.spde.make.index("s",
n.spde = spde$n.spde,
n.group = timesn
)
lengths(indexs)
# Projection matrix
group <- d$year - min(d$year) + 1
A <- inla.spde.make.A(mesh = mesh, loc = coo, group = group)
# Prediction data
bb <- st_bbox(m)
x <- seq(bb$xmin - 1, bb$xmax + 1, length.out = 50)
y <- seq(bb$ymin - 1, bb$ymax + 1, length.out = 50)
dp <- as.matrix(expand.grid(x, y))
plot(dp, asp = 1)
p <- st_as_sf(data.frame(x = dp[, 1], y = dp[, 2]),
coords = c("x", "y")
)
st_crs(p) <- st_crs(25830)
ind <- st_intersects(m, p)
dp <- dp[ind[[1]], ]
plot(dp, asp = 1)
dp <- rbind(cbind(dp, 1), cbind(dp, 2), cbind(dp, 3))
head(dp)
coop <- dp[, 1:2]
groupp <- dp[, 3]
Ap <- inla.spde.make.A(mesh = mesh, loc = coop, group = groupp)
stk.e <- inla.stack(
tag = "est",
data = list(y = d$value),
A = list(1, A),
effects = list(data.frame(b0 = rep(1, nrow(d))), s = indexs)
)
stk.p <- inla.stack(
tag = "pred",
data = list(y = NA),
A = list(1, Ap),
effects = list(data.frame(b0 = rep(1, nrow(dp))), s = indexs)
)
stk.full <- inla.stack(stk.e, stk.p)
# formula
rprior <- list(theta = list(prior = "pccor1", param = c(0, 0.9)))
formula = y ~ -1 + b0 + f(s,
model = spde, group = s.group,
control.group = list(model = "ar1", hyper = rprior))
fit <- inla(formula,
data = inla.stack.data(stk.full, spde=spde),
family = "gaussian",
control.predictor = list(A = inla.stack.A(stk.full),
compute = TRUE),
control.compute = list(return.marginals.predictor = TRUE))
# Example Moraga book
library(lwgeom)
library(raster)
m <- getData(name = "GADM", country = "Spain", level = 0)
plot(m)
#
library(sf)
library(dplyr)
m <- m %>%
st_as_sf() %>%
st_cast("POLYGON") %>%
mutate(area = st_area(.)) %>%
arrange(desc(area)) %>%
slice(1)
#
library(ggplot2)
ggplot(m) + geom_sf() + theme_bw()
m <- m %>% st_transform(25830)
ggplot(m) + geom_sf() + theme_bw() + coord_sf(datum = st_crs(m))
#### Read data
d <- read.csv("dataPM25.csv")
d <- d[, c(
"ReportingYear", "StationLocalId",
"SamplingPoint_Longitude",
"SamplingPoint_Latitude",
"AQValue"
)]
names(d) <- c("year", "id", "long", "lat", "value")
library(sf)
p = st_as_sf(data.frame(long = d$long, lat = d$lat),
coords = c("long", "lat"))
st_crs(p) = st_crs(4326)
p = p %>% st_transform(25830)
d[, c("x", "y")] = st_coordinates(p)
ind <- st_intersects(m, p)
d <- d[ind[[1]], ]
p <- st_as_sf(data.frame(long = d$long, lat = d$lat),
coords = c("long", "lat"))
st_crs(p) <- st_crs(4326)
p <- p %>% st_transform(25830)
d[, c("x", "y")] <- st_coordinates(p)
# keep station in the main territory of Spain
ind <- st_intersects(m, p)
d <- d[ind[[1]], ]
ggplot(m) + geom_sf() + coord_sf(datum = st_crs(m)) +
geom_point(data = d, aes(x = x, y = y)) + theme_bw()
ggplot(m) + geom_sf() + coord_sf(datum = NA) +
geom_point(
data = d, aes(x = x, y = y, color = value),
size = 2
) +
labs(x = "", y = "") +
scale_color_viridis() +
facet_wrap(~year) +
theme_bw()
# mesh
sc<- 1/1000 ##scaling
coo <- cbind(d$x, d$y)*sc
bnd <- inla.nonconvex.hull(st_coordinates(m)[, 1:2]*sc)
mesh <- inla.mesh.2d(
loc = coo, boundary = bnd,
max.edge = c(100000, 200000)*sc, cutoff = 1000*sc
)
plot(mesh)
points(coo, col = "red")
spde <- inla.spde2.pcmatern(
mesh = mesh, alpha = 2, constr = TRUE,
prior.range = c(10000, 0.01), # P(range < 10000) = 0.01
prior.sigma = c(3, 0.01) # P(sigma > 3) = 0.01
)
timesn <- length(unique(d$year))
indexs <- inla.spde.make.index("s",
n.spde = spde$n.spde,
n.group = timesn
)
lengths(indexs)
group <- d$year - min(d$year) + 1
A <- inla.spde.make.A(mesh = mesh, loc = coo, group = group)
# Prediction data
bb <- st_bbox(m)
x <- seq(bb$xmin - 1, bb$xmax + 1, length.out = 50)
y <- seq(bb$ymin - 1, bb$ymax + 1, length.out = 50)
dp <- as.matrix(expand.grid(x, y))
plot(dp, asp = 1)
# keep only locations within borders of spain
p <- st_as_sf(data.frame(x = dp[, 1], y = dp[, 2]),
coords = c("x", "y")
)
st_crs(p) <- st_crs(25830)
ind <- st_intersects(m, p)
dp <- dp[ind[[1]], ]
plot(dp, asp = 1)
# Now we construct the data that includes the coordinates and
#the three times by repeating dp three times and adding a column denoting the times.
#Here time 1 is 2015, time 2 is 2016, and time 3 is 2017.
dp <- rbind(cbind(dp, 1), cbind(dp, 2), cbind(dp, 3))
head(dp)
coop <- dp[, 1:2]
groupp <- dp[, 3]
Ap <- inla.spde.make.A(mesh = mesh, loc = coop, group = groupp)
# Stacks
stk.e <- inla.stack(
tag = "est",
data = list(y = d$value),
A = list(1, A),
effects = list(data.frame(b0 = rep(1, nrow(d))), s = indexs)
)
stk.p <- inla.stack(
tag = "pred",
data = list(y = NA),
A = list(1, Ap),
effects = list(data.frame(b0 = rep(1, nrow(dp))), s = indexs)
)
stk.full <- inla.stack(stk.e, stk.p)
# formula
rprior <- list(theta = list(prior = "pccor1", param = c(0, 0.9)))
formula = y ~ -1 + b0 + f(s,
model = spde, group = s.group,
control.group = list(model = "ar1", hyper = rprior))
inla.setOption(inla.mode="experimental")
# https://github.com/julianfaraway/rexamples/blob/main/mixed/jspmultilevel.md
# inla call
fit <- inla(formula,
data = inla.stack.data(stk.full, spde=spde),
family = "gaussian",
control.predictor = list(A = inla.stack.A(stk.full),
compute = TRUE),
control.compute = list(return.marginals.predictor = TRUE), control.inla=list(cmin=0),
verbose = TRUE)
fit$summary.fixed
fit$summary.hyperpar
index <- inla.stack.index(stack = stk.full, tag = "pred")$data
index <- inla.stack.index(stack = stk.full, tag = "pred")$data
dp <- data.frame(dp)
names(dp) <- c("x", "y", "time")
dp$pred_mean <- res$summary.fitted.values[index, "mean"]
dp <- data.frame(dp)
names(dp) <- c("x", "y", "time")
dp$pred_mean <- fit$summary.fitted.values[index, "mean"]
dp$pred_ll <- fit$summary.fitted.values[index, "0.025quant"]
dp$pred_ul <- fit$summary.fitted.values[index, "0.975quant"]
library(reshape2)
dpm <- melt(dp,
id.vars = c("x", "y", "time"),
measure.vars = c("pred_mean", "pred_ll", "pred_ul")
)
head(dpm)
ggplot(m) + geom_sf() + coord_sf(datum = NA) +
geom_tile(data = dpm, aes(x = x, y = y, fill = value)) +
labs(x = "", y = "") +
facet_wrap(variable ~ time) +
scale_fill_viridis("PM2.5") +
theme_bw()
View(dp)
Ap <- inla.spde.make.A(mesh = mesh, loc = coop, group = groupp, n.group=3)
stk.p <- inla.stack(
tag = "pred",
data = list(y = NA),
A = list(1, Ap),
effects = list(data.frame(b0 = rep(1, nrow(dp))), s = indexs)
)
stk.full <- inla.stack(stk.e, stk.p)
formula = y ~ -1 + b0 + f(s,
model = spde, group = s.group,
control.group = list(model = "ar1", hyper = rprior))
fit <- inla(formula,
data = inla.stack.data(stk.full, spde=spde),
family = "gaussian",
control.predictor = list(A = inla.stack.A(stk.full),
compute = TRUE),
control.compute = list(return.marginals.predictor = TRUE), control.inla=list(cmin=0),
verbose = TRUE)
fit$summary.fixed
fit$summary.hyperpar
index <- inla.stack.index(stack = stk.full, tag = "pred")$data
dp <- data.frame(dp)
names(dp) <- c("x", "y", "time")
dp$pred_mean <- fit$summary.fitted.values[index, "mean"]
dp$pred_ll <- fit$summary.fitted.values[index, "0.025quant"]
dp$pred_ul <- fit$summary.fitted.values[index, "0.975quant"]
library(reshape2)
dpm <- melt(dp,
id.vars = c("x", "y", "time"),
measure.vars = c("pred_mean", "pred_ll", "pred_ul")
)
head(dpm)
ggplot(m) + geom_sf() + coord_sf(datum = NA) +
geom_tile(data = dpm, aes(x = x, y = y, fill = value)) +
labs(x = "", y = "") +
facet_wrap(variable ~ time) +
scale_fill_viridis("PM2.5") +
theme_bw()
ggplot(m) + geom_sf() + coord_sf(datum = NA) +
geom_point(
data = d, aes(x = x, y = y, color = value),
size = 2
) +
labs(x = "", y = "") +
scale_color_viridis() +
facet_wrap(~year) +
theme_bw()
sc<- 1/1000 ##scaling
coo <- cbind(d$x, d$y)*sc
bnd <- inla.nonconvex.hull(st_coordinates(m)[, 1:2]*sc)
mesh <- inla.mesh.2d(
loc = coo, boundary = bnd,
max.edge = c(100000, 200000)*sc, cutoff = 1000*sc
)
plot(mesh)
points(coo, col = "red")
spde$n.spde
2.5*2.5
