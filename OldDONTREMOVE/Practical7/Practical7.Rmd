---
title: 'Practical 7: Vaccination uptake'
author: "Bayesian modelling for Spatial and Spatio-Temporal data"
output: 
  html_document:
    toc: true
    toc_float: true
---

\pagenumbering{gobble} 
\pagenumbering{arabic} 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE, fig.align = "center", class.source='klippy')
```

```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy(position = c('top', 'right'),color = 'darkred',
               tooltip_message = 'Click to copy', tooltip_success = 'Done')
```



### WHAT?

In this pratical we will use real data to get familiar with spatial modelling of areal level data. The scientific paper of reference is: Bucyibaruta G, Blangiardo M, Konstantinoudis G. Community-level characteristics of COVID-19 vaccine hesitancy in England: A nationwide cross-sectional study. European Journal of Epidemiology. 2022 Oct;37(10):1071-81, https://link.springer.com/article/10.1007/s10654-022-00905-1


### WHY?

We want to assess the spatial pattern of a particular health outcome and to identify areas characterized by unusually high or low relative risk.

### Breif description of the data

In this study, the data are available at the area level (Middle Layer Super Output Area - MSOA) for England and consist of aggregated counts of outcome and covariates.

To examine the determinants of vaccine uptake at high spatial resolution, we consider covariates related with socio-demographics, political-opinion, COVID-19 mortality during 2020, mental and physical chronic health conditions as well as vaccine accessibility. In particular:  
 * To characterise the socio-demographic profile of each area we use percentage of Black and Minority ethnic (BME), index of multiple deprivation (IMD), percentage of 12-24 years old and percentage of over 65 years old in each MSOA. 

 * We classify each MSOA based on its level of urbanicity (Predominantly Urban (PU), Urban with Significant Rural (UR), and Predominantly Rural (PR)).  

 * To characterise the political-opinion of an area, we use the percentage who voted to leave the EU at the 2016 referendum and the results from the 2019 General election. 

 * To describe the awareness of the COVID-19 health risks and the targeting of high risk groups, we include the COVID-19 mortality rates during 2020, covering the pre-vaccination campaign period,  as well as the prevalence of asthma,  high blood pressure, diabetes, and depression. 

 * The COVID-19 vaccine accessibility is estimated based on the distance between vaccination sites and MSOA population weighted centroids.

###  Model 
The model is specified in a Bayesian framework by simply extending
the concept of hierarchical structure, allowing us to account for similarities based on the neighborhood.


## Model specification
We considered $y_i$ to be the number of people who have received the first dose of COVID-19 vaccine and $n_i$ the number of eligible people to receive the vaccine for each MSOA ($i=1,\dots,6791$).
We assumed a Binomial distribution for the number of vaccinations and modeled the proportion $p_i$ as follows:

\[ 
   y_i  \sim \mbox{Bin}(p_i,n_i) 
 \] 
  with 
\[
 \mbox{logit} (p_i)  =\beta_0+\sum_{k=1}^K\sum_{m}\beta_{km} X_{ikm}+ b_i
\]
  and
\[
b_i = \frac{1}{\sqrt{\tau_b}}( \sqrt{(1-\phi} v_{i}^*+\sqrt{\phi} u_{i}^*)
\],

where $\beta_0$ is the overall vaccination uptake across England, $X_{ikm}$ is the dummy variable for the $k^{th} (k=1,\ldots,K)$ covariate in the $m^{th}$ category ($m=2,\ldots,5$, except for urbanicity where $m=2,3$) and $\boldsymbol{\beta}$ are the corresponding effects. 

Additionally, $b_i$ represents the weighted average of a spatially structured and unstructured random effect, so that the model borrows strength from the other areas across the entire study region, as well as from the neighbouring ones.

#  Loading the required packages

```{r,warning=FALSE}

library(readODS)
library(sf)
library(leaflet)
library(RColorBrewer)
library(tidyverse)
library(xtable)
library(classInt)
library(viridis)
library(gridExtra)
library(Hmisc)
library(INLA)
library(spdep)
library(ggplot2)
library(patchwork)
library(ghibli)
library(ggplotify)
library(ggtext)
```

# 1. Import a shape file and data 

## a. download and read the shapefile

we upload the shape file, through the function `st_read`  of the `sf` package.

```{r,warning=FALSE}
### MSOA boundaries from https://borders.ukdataservice.ac.uk/

# Read the MSOA shape file
msoa_poly = st_read("england_msoa_2011_sgen_clipped.shp")

# Fix projection
msoa_poly = st_transform(msoa_poly, 4326)
#keep planar coordinate, (for INLA)
sf::sf_use_s2(FALSE)
```

Note: To know more about `st_use_s2` function, you may proceed like `?st_use_s2`.

The geometry of the shape file:

```{r}
plot(msoa_poly$geometry)
```


## b. Loading  the vaccination data

```{r}
## Loading  the  data
data_Vaccine = read.csv("msoa_2022-01-02.csv",header = T)

# Renaming variables
names(data_Vaccine)[6] = "PopVac"
names(data_Vaccine)[7] = "Cum_firstDose"
names(data_Vaccine)[8] = "First_dosePct"

```

# 2. Data preparation

## a. Combining map coordinates with vaccination data. We use the `merge` function from the `base` package

```{r}
# Combining map coordinates with vaccination data
vac_poly_Dec = merge(msoa_poly, data_Vaccine[,c(3,6,7,8)],  by.x = "code", by.y = "areaCode", all.x = T)
```

## b. Loading covariates data

```{r}
##################--Covariate in orginal scale--------#################
datav_og = read.csv("DataVac_OG.csv", header = T)
datav_og = datav_og[,-c(1,3,4,5,6,12,16,24,29,30)]
```

## c. Data transformation

```{r}
datav_og$rateCat = factor(datav_og$rateCat)
datav_og$rateCat = relevel(datav_og$rateCat,ref = "low")
datav_og$imd_decile_msoaLast = factor(datav_og$imd_decile_msoaLast)
datav_og$B_RUC11 = factor(datav_og$B_RUC11)

datav_og$B_RUC11 = relevel(datav_og$B_RUC11,ref = "PU")

datav_og = fastDummies::dummy_cols(datav_og,
                                    select_columns = "B_RUC11",
                                    remove_first_dummy = TRUE)

vac_poly_Dec_og = merge(vac_poly_Dec, datav_og,  by.x = "code",
                         by.y = "areaCode", all.x = T)

```

### Convert covariates into categories

```{r}
vac_poly_Dec_og$bmeG = cut2(vac_poly_Dec_og$bme,g=5)
levels(vac_poly_Dec_og$bmeG) = c("1(low)", "2","3","4","5")

vac_poly_Dec_og$leave = cut2(vac_poly_Dec_og$Pct_Leave,g=5)
levels(vac_poly_Dec_og$leave) = c("1(low)", "2","3","4","5")

vac_poly_Dec_og$asthma = cut2(vac_poly_Dec_og$Asthma,g=5)
levels(vac_poly_Dec_og$asthma) = c("1(low)", "2","3","4","5")

vac_poly_Dec_og$diabetes = cut2(vac_poly_Dec_og$Diabetes,g=5)
levels(vac_poly_Dec_og$diabetes) = c("1(low)", "2","3","4","5")

vac_poly_Dec_og$bp = cut2(vac_poly_Dec_og$blood_pre,g=5)
levels(vac_poly_Dec_og$bp) = c("1(low)", "2","3","4","5")

vac_poly_Dec_og$depression = cut2(vac_poly_Dec_og$Depression,g=5)
levels(vac_poly_Dec_og$depression) = c("1(low)", "2","3","4","5")

vac_poly_Dec_og$Cons = cut2(vac_poly_Dec_og$Pct_con,g=5)
levels(vac_poly_Dec_og$Cons) = c("1(low)", "2","3","4","5")

vac_poly_Dec_og$LAB = cut2(vac_poly_Dec_og$Pct_LAB,g=5)
levels(vac_poly_Dec_og$LAB) = c("1(low)", "2","3","4","5")

vac_poly_Dec_og$death = cut2(vac_poly_Dec_og$rates,g=5)
levels(vac_poly_Dec_og$death) = c("1(low)", "2","3","4","5")

vac_poly_Dec_og$young = cut2(vac_poly_Dec_og$pctYoungAge,g=5)
levels(vac_poly_Dec_og$young) = c("1(low)", "2","3","4","5")

vac_poly_Dec_og$old = cut2(vac_poly_Dec_og$PctOld,g=5)
levels(vac_poly_Dec_og$old) = c("1(low)", "2","3","4","5")

vac_poly_Dec_og$imd_rank_msoaLast = round(rank(-vac_poly_Dec_og$imd_medianS_msoa))
vac_poly_Dec_og$imd_quintile = cut2(vac_poly_Dec_og$imd_rank_msoaLast, g=5)
levels(vac_poly_Dec_og$imd_quintile) = 
  c("low", "second","third","fourth","high")
vac_poly_Dec_og$imd_quintile = relevel(vac_poly_Dec_og$imd_quintile,ref = "high")

vac_poly_Dec_og$urbanicity = vac_poly_Dec_og$B_RUC11

##--------- Select data in categories------------##

vac_poly_Category = vac_poly_Dec_og[,c(1,2,3,4,5,46:60)]
vac_poly_Category$imd_quintileNew = ifelse(vac_poly_Category$imd_quintile=="low", "5",
                                ifelse(vac_poly_Category$imd_quintile=="second", "4",
                                       ifelse(vac_poly_Category$imd_quintile=="third","3",
                                              ifelse(vac_poly_Category$imd_quintile=="fourth","2",
                                                     "1(least)"))))
vac_poly_Category$imd_quintileNew = factor(vac_poly_Category$imd_quintileNew, levels = c("1(least)", "2","3","4","5"))

```

## d. Loading vaccination access data

```{r}
Vac_Acces = read.csv("Weighted_VAc_Acc_Data.csv")

vac_poly_Category = merge(vac_poly_Category, Vac_Acces[,c(2,7,8)], 
                           by.x = "code", by.y = "code", all.x = T)

vac_poly_Category$WVA = cut2(vac_poly_Category$WeightVacAcc, g=5)
levels(vac_poly_Category$WVA) = c("1(low)", "2","3","4","5")
```

## e. Spatial visualization

Spatial distribution of covariates

```{r}
# Black and Minority ethnic (BME)
Bme = vac_poly_Category %>% 
  ggplot() + 
  geom_sf(aes(fill = bmeG), color = NA, show.legend = TRUE) +
  theme_void() +
  scale_fill_viridis_d(option = "viridis",direction = -1,begin = 0.5,end=1)+
  theme(legend.position = c(0.92, 0.85),
        legend.title =  element_blank(),
        plot.title = element_text(size=9, face = "bold",hjust = 0.5))+
  labs(fill='BME')+
  ggtitle("BME")

# index of multiple deprivation (IMD)
imd = vac_poly_Category %>% 
  ggplot() + 
  geom_sf(aes(fill = imd_quintileNew), color = NA, show.legend = TRUE) +
  theme_void() +
  scale_fill_viridis_d(option = "viridis",direction = -1,begin = 0.5,end=1)+
  theme(legend.position = c(0.92, 0.85),
        legend.title = element_text(face="bold"),
        plot.title = element_text(size=9, face = "bold",hjust = 0.5))+
  labs(fill='IMD')+
  ggtitle("IMD")
```

```{r}
Socio = (imd/Bme)

Socio + plot_layout(guides = "collect")+
  plot_annotation(title = "BME and IMD ",
                  theme = theme(plot.title = element_text(face = "bold",
                                                          size= 14)))
```

# 3. Model fitting 

## a. Adjacency matrix

    *Activity 1: 
   
Use the `poly2nb`  and `nb2INLA` functions from the `spdep` package to transform the shape file into an adjacency matrix and to make it compatible with the R-INLA format. 
Create the identifiers for the areas and call is as `reid`. Then create the adjacency map and call it as `map_adj`

```{r,include=FALSE}
vac_poly_Category$reid = 1:nrow(vac_poly_Category)

nb = poly2nb(vac_poly_Category)

nb2INLA("map_adj",nb)
```

    * Activity 2: 
    
The last command creates an object (`map_adj`) with the location of the graph.

Now we have a file called `map_adj` stored in the current working directory,
which is in the right format to be read by R-INLA, and we store it in an object called `g`. 

The graph can be imported in R-INLA using the `inla.read.graph` function (see `?inla.read.graph`)

```{r,include=FALSE}
# Graph
g = inla.read.graph(filename="map_adj")
```


## b. Inference using INLA

      * Activity 3: 
      
After having defined the neighborhood structure, we  specify the formula object to investigate the effect of the covariates on the response (`Cum_firstDose`). Call the formula as `vac_formula`.

We also assume that the vaccination rates across MSOAs are not similar in some
way, and specify a `BYM2` as random effects model for the true mortality rates $p_i$.

Then, we call `inla()` specifying the formula, the data, the family of the likelihood and the number of trials. Call the model as `vac_model`.

Note that `reid` represents the identifiers for the areas and through the graph option
we include the name of the object containing the neighborhood structure.

      * Hints:
  
            *  family = binomial
            
            * Required arguments: y and n (keyword Ntrials)

  * Specification:

model = inla(formula, family = "binomial", data = data, Ntrials=Ntrials)

(see: https://inla.r-inla-download.org/r-inla.org/doc/likelihood/binomial.pdf)

We add: 
    * `control.predictor = list(compute = TRUE)` to compute the
    posterior marginals of the parameters and 

   * `control.compute =list(dic = TRUE, waic = TRUE)` to indicate that the DIC and WAIC should be computed
   
We call the result as `vac_model` 
   
```{r,warning=FALSE, echo=FALSE, include=FALSE}
# With spatial (all categorical)
vac_formula = Cum_firstDose ~ bmeG+imd_quintileNew+young+old+
  urbanicity +LAB+Cons+leave+death+
  asthma+bp+diabetes+depression+WVA+
  f(reid,model="bym2",graph = g,scale.model =TRUE)


vac_model = inla(vac_formula, family = "binomial", 
                          data = vac_poly_Category, Ntrials=PopVac,
                          control.predictor = list(compute=TRUE),
                          control.compute=list(dic=TRUE,waic = TRUE,config = TRUE))
```


## 4. Results

When `inla()` is executed, we obtain an object of class inla that contains the
information of the fitted model including summaries and posterior marginal
densities of the fixed effects, the random effects, the hyperparameters, the
linear predictors, and the fitted values.

We can inspect the results object `vac_model` by using `summary` function.

The DIC is based on a trade-off between the fit of the data to the model and 
the complexity of the model with smaller values of DIC indicating
a better model.

```{r,include=FALSE}
summary(vac_model)
```
Here: 
- `Precision for reid` refers to $\tau_b$, i.e. the marginal variance of the random effect

- `Phi for reid` refers to $\phi$, i.e. the mixing parameter measuring the proportion of the marginal variance explained by the structured effect $\boldsymbol{u}_{*}$. The BYM2 model is equal to an only spatial model when $\phi = 1$, and an only unstructured spatial noise when $\phi = 0$.



# 5. Mapping the predicted values (median) for vaccine uptake

We can obtain the summaries of the odds ratios (OR) including the mean posterior and the lower and upper limits of 95% credible intervals of the OR using `vac_model$summary.fitted.values`. Specifically, column mean is the mean posterior and 0.025quant, 0.5quant and 0.975quant are the 2.5 the 50 and 97.5 percentiles.


```{r}
pred = vac_model$summary.fitted.values$`0.5quant` # keep median

# the 95%CI could be obtained as follows
#low = vac_model$summary.fitted.values$`0.025quant`
#high = vac_model$summary.fitted.values$`0.975quant`

vac_poly_Category$predictor = pred*100 # using percentage for better interpretability

# different methods to build categories
# vac_poly_Category$groupPred = cut2(vac_poly_Category$predictor,g=5) 
# Q_prob = quantile(vac_poly_Category$predictor,probs = c(0.2,0.4,0.6,0.8))

vac_poly_Category$group = cut2(vac_poly_Category$predictor,cuts=c(50,60,70,80,90),g=6) # we cut them into intervals

# MSOAs with posterior median for fitted values <= 50 %
# Vac_low = vac_poly_Category[vac_poly_Category$predictor<=50,]

# MSOAs with posterior median for fitted values >=92 %
Vac_high = vac_poly_Category[vac_poly_Category$predictor>=92,]
```

### Map MSOAs with high vaccination uptake (median for fitted values >= 92)


```{r}
hh = vac_poly_Category %>%
ggplot()+
  geom_sf(aes(fill=NULL))+
  geom_sf(data = Vac_high, aes(fill =predictor),col="red")+
  theme_void()+
  theme(legend.title =element_text(size = 2))+
  scale_fill_viridis_c(option = "magma", direction=-1) + # reverse the scale of colors
  ggtitle("High vaccine uptake")

hh
```

###  Vaccine Uptake and large cities

    * Activity 4:
   
      * Read the shape file of the major cities from your working directory
      
      * Fix the projection to EPSG numeric code 4326
      
      * Select four big cities (London, Birmingham, Liverpool and Bristol) and visualize the results
  

```{r,include=FALSE}
######-----vaccine Uptake and large cities--------------------##########
cities = read_sf("Major_Towns_and_Cities_(December_2015)_Boundaries_V2.shp")
cities = st_transform(cities, 4326)

#https://www.thegeographist.com/uk-cities-population-1000/

London = cities[cities$TCITY15NM %in% "London",]           # 8,907,918
Birmingham = cities[cities$TCITY15NM %in% "Birmingham",]   # 1,153,717
Liverpool = cities[cities$TCITY15NM %in% "Liverpool",]     # 579,256
Bristol = cities[cities$TCITY15NM %in% "Bristol",]         # 571,922

```

- Now we visualize the spatial distribution of vaccine uptake across the 4 cities and the England 

To visualize the results for the four city, you can use as an example of code for mapping Bristol vaccine uptake:

```{r, echo=TRUE}
# Bristol
Bris = st_intersection(vac_poly_Category, cities[cities$TCITY15NM %in% "Bristol",]) %>% 
  ggplot() + 
  geom_sf(aes(fill = group), col = NA, show.legend = F) +
  geom_sf(data = Bristol, fill = NA,col=NA) +
  scale_fill_viridis_d(option = "viridis",direction = -1,begin = 0.2,end=1) +
  theme_void() +
  theme(legend.title =  element_blank(),
        plot.title = element_text(hjust = 0.5,face = "bold"))+
  ggtitle("Bristol")
```
Note that `st_intersection` in the `sf` package returns a geometry for the intersection. 

Do the same for London (call the graph object as `L`), Birmingham (call the graph as `Bir`), Liverpool (call the graph object as `Liv`). 


- Then, run the following code to obtain the map for England

```{r, echo=TRUE, results='hide'}
 England = vac_poly_Category %>% 
  ggplot() + 
  geom_sf(aes(fill = group), color = NA, show.legend = TRUE) +
  geom_sf(data = London, colour = "red", fill = NA, size = .1) + 
  geom_sf(data = Birmingham, colour = "red", fill = NA, size = .1) + 
  geom_sf(data = Liverpool, colour = "red", fill = NA, size = .1) + 
  geom_sf(data = Bristol, colour = "red", fill = NA, size = .1) + 
  scale_fill_viridis_d(option = "viridis",direction = -1,begin = 0.2,end=1)+
  theme_void() +
  theme(legend.position = c(0.92, 0.85),
        legend.title =  element_blank(),
        legend.text = element_text(size=14),
        plot.margin = margin(t = 0,  # Top margin
                             r = 0,  # Right margin
                             b = 0,  # Bottom margin
                             l = 0) # Left margin
        ,plot.title = element_text(hjust = 0.5,face = "bold"))+
  ggtitle("England") 

```

- Put all the maps together using the code below
```{r, echo=TRUE, include=FALSE, eval=FALSE}
p_all=England|((Liv|Bir)/(Bris|L))

x11()  # call external window for plotting

p_all +plot_layout(guides = "collect")+
  plot_annotation(title = "")

```


# 6. Exceedance probabilities using residual odds ratio (OR)

Generally speaking, in `R-INLA`, the probability $P(\theta_i \le c)$ can be calculated using the `inla.pmarginal()` function with arguments equal to the marginal distribution
of $\theta_i$ and the threshold value c.

The OR of the predictors can be calculated by exponentiating their estimated coefficients.

Thus, we can visualize $p(exp(b_i)) \le 1)$ (or equivalently $p(b_i \le 0)$ which is easier to obtain) using the built-in function `inla.pmarginal`.


```{r}
re = vac_model$marginals.random$reid[1:6791] # latent random effects
a = 0
prob.re = lapply(re, function(x) {inla.pmarginal(a, x)})


Exc.prob = round(unlist(prob.re),2)

vac_poly_Category$exceed.prob = Exc.prob
vac_poly_Category$excProb = cut2(vac_poly_Category$exceed.prob,g=3,cuts = c(0.2,0.8)) 

# Map of posterior probabilities that the area-level odds of vaccination coverage are lower than the national average
EX.Pro = vac_poly_Category %>% 
  ggplot() + 
  geom_sf(aes(fill = excProb), color = NA, show.legend = TRUE)+
  scale_fill_viridis_d(option = "viridis",direction = 1,begin = 0.2,end=1)+
  theme_void() +
  theme(legend.title = element_blank(),
        plot.title = element_text(size=9,face = "bold",hjust = 0.5))+
  ggtitle(" Exceedance Probability ")

EX.Pro
```

- Comment the map.

- You can obtain the same maps on residual PP for London, Bristol, Birmingham, Liverpool using using `st_intersection` as we did before. In detail,  call the graphs as follows: `L_ex`, `Bir_ex`, `Liv_ex` and `Bris_ex` respectively for London, Birmingham, Liverpool and Bristol. Then put the maps together using the package `patchwork` as we did before


```{r, eval=FALSE, echo=FALSE}
L_ex = st_intersection(vac_poly_Category, cities[cities$TCITY15NM %in% "London",]) %>% 
  ggplot() + 
  geom_sf(aes(fill = excProb), col = NA, show.legend = F) +
  geom_sf(data = London, fill = NA,col=NA) +
  scale_fill_viridis_d(option = "viridis",direction = 1,begin = 0.2,end = 1)+
  theme_void() +
  theme(legend.title =  element_blank(),
        plot.title = element_text(hjust = 0.5,face = "bold"))+
  ggtitle("London")
L_ex

Bir_ex = st_intersection(vac_poly_Category, cities[cities$TCITY15NM %in% "Birmingham",]) %>% 
  ggplot() + 
  geom_sf(aes(fill = excProb), col = NA, show.legend = F) +
  geom_sf(data = Birmingham, fill = NA,col=NA) +
  scale_fill_viridis_d(option = "viridis",direction = 1,begin = 0.2,end = 1)+
  theme_void() +
  theme(legend.title =  element_blank(),
        plot.title = element_text(hjust = 0.5,face = "bold"))+
  ggtitle("Birmingham")
Bir_ex

Liv_ex = st_intersection(vac_poly_Category, cities[cities$TCITY15NM %in% "Liverpool",]) %>% 
  ggplot() + 
  geom_sf(aes(fill = excProb), col = NA, show.legend = F) +
  geom_sf(data = Liverpool, fill = NA,col=NA) +
  scale_fill_viridis_d(option = "viridis",direction = 1,begin = 0.2,end = 1)+
  theme_void() +
  theme(legend.title =  element_blank(),
        plot.title = element_text(hjust = 0.5,face = "bold"))+
  ggtitle("Liverpool")
Liv_ex

Bris_ex = st_intersection(vac_poly_Category, cities[cities$TCITY15NM %in% "Bristol",]) %>% 
  ggplot() + 
  geom_sf(aes(fill = excProb), col = NA, show.legend = F) +
  geom_sf(data = Bristol, fill = NA,col=NA) +
  scale_fill_viridis_d(option = "viridis",direction = 1,begin = 0.2,end = 1)+
  theme_void() +
  theme(legend.title =  element_blank(),
        plot.title = element_text(hjust = 0.5,face = "bold"))+
  ggtitle("Bristol")
Bris_ex


 a_ex = vac_poly_Category %>% 
  ggplot() + 
  geom_sf(aes(fill = excProb), color = NA, show.legend = TRUE) +
  geom_sf(data = London, colour = "red", fill = NA, size = .1) + 
  geom_sf(data = Birmingham, colour = "red", fill = NA, size = .1) + 
  geom_sf(data = Liverpool, colour = "red", fill = NA, size = .1) + 
  geom_sf(data = Bristol, colour = "red", fill = NA, size = .1) + 
  scale_fill_viridis_d(option = "viridis",direction = 1,begin = 0.2,end = 1)+
  theme_void() +
  theme(legend.position = c(0.92, 0.85),
        legend.title =  element_blank(),
        legend.text = element_text(size=14),
        plot.margin = margin(t = 0,  # Top margin
                             r = 0,  # Right margin
                             b = 0,  # Bottom margin
                             l = 0) # Left margin
        ,plot.title = element_text(hjust = 0.5,face = "bold"))+
  ggtitle("England") 
a_ex


p_ex=a_ex|((Liv_ex|Bir_ex)/(Bris_ex|L_ex))

x11() # call external window for plotting

p_ex +plot_layout(guides = "collect")+
  plot_annotation(title = "")

```

