150*7
80*7
1050+560+1600+100
3500*4
50*7
350+50+1600+560+1050
3610*4
36+12
3600*2
8/4
80*7
500+300+100+200+100
1200*4
300000+70000+50000
55*2*8
880+880
1000/48
500?28
500/28
55*2*9
990+990
55*2*0.2
32*0.2
55*2*18
2010-1997
3000*5
3000*4
12000+3000+6000
12000+3000+3000
2000*9
3000*6
12*4
55*9*2
35*5*2
350+990
1340*2
12-700
12000-7000
11-2.5
7.5+3.5
1088*5
1500*12
430000-60000
1.5+3.5+1+1+1
library("bayesmix")
install.packages("bayesmix")
library("bayesmix")
data("fish", package = "bayesmix")
x <- fish[ , 1]
n <- length(x)
K <- 5
m <- 11000
burn <- 1000
model <- BMMmodel(fish, k = K, initialValues = list(S0 = 2),
+ priors = list(kind = "independence", parameter = "priorsFish",
+ hierarchical = "tau"))
model <- BMMmodel(fish, k = K, initialValues = list(S0 = 2),
priors = list(kind = "independence", parameter = "priorsFish",
hierarchical = "tau"))
model <- BMMmodel(fish, k = 4, priors = list(kind = "independence",
parameter = "priorsFish", hierarchical = "tau"),
initialValues = list(S0 = 2))
library("bayesmix")
library("bayesmix")
model <- BMMmodel(fish, k = K, initialValues = list(S0 = 2),
priors = list(kind = "independence",
parameter = "priorsFish",
hierarchical = "tau"))
control <- JAGScontrol(variables = c("mu", "tau", "eta", "S"),
burn.in = burn, n.iter = m, seed = 10)
mcmc <- JAGSrun(fish, model = model, control = control)
View(mcmc)
help(print.JAGSmodel)
head(fish)
J <- 3
mcmc.pars <- array(data = NA, dim = c(m, K, J))
mcmc.pars[ , , 1] <- mcmc$results[-(1:burn), (n+K+1):(n+2*K)]
mcmc.pars[ , , 2] <- mcmc$results[-(1:burn), (n+2*K+1):(n+3*K)]
J <- 3
mcmc.pars <- array(data = NA, dim = c(m, K, J))
mcmc.pars[ , , 3] <- mcmc$results[-(1:burn), (n+1):(n+K)]
z <- mcmc$results[-(1:burn), 1:n]
mcmc$results
mcmc.pars[ , , 1] <- mcmc$results[-(1:burn), (n+K+1):(n+2*K)]
View(z)
p <- array(data = NA, dim = c(m, n, K))
for (iter in 1:m){
for(i in 1:n){
kdist <- mcmc.pars[iter, , 3]*dnorm(x[i], mcmc.pars[iter, , 1],
+ sqrt(mcmc.pars[iter, , 2]))
skdist <- sum(kdist)
for(j in 1:K){
p[iter, i, j] = kdist[j]/skdist}}}
p
dim(p)
#load a toy example: MCMC output consists of the random beta model
# applied to a normal mixture of \code{K=2} components. The number
# of observations is equal to \code{n=5}. The number of MCMC samples
# is equal to \code{m=300}. The matrix of allocation probabilities
# is stored to matrix \code{p}.
data("mcmc_output")
data("mcmc_output", package = "bayesmix)
# mcmc parameters are stored to array \code{mcmc.pars}
mcmc.pars<-data_list$"mcmc.pars"
# mcmc.pars[,,1]: simulated means of the two components
# mcmc.pars[,,2]: simulated variances
# mcmc.pars[,,3]: simulated weights
# the computed allocation matrix is p
p<-data_list$"p"
run<-stephens(p)
# apply the permutations returned by typing:
reordered.mcmc<-permute.mcmc(mcmc.pars,run$permutations)
# reordered.mcmc[,,1]: reordered means of the components
# reordered.mcmc[,,2]: reordered variances
# reordered.mcmc[,,3]: reordered weights
data("mcmc_output", package = "bayesmix")
library("label.switching")
data("mcmc_output")
# mcmc parameters are stored to array \code{mcmc.pars}
mcmc.pars<-data_list$"mcmc.pars"
mcmc.pars[,,1]: simulated means of the two components
mcmc_output
data("mcmc_output")
data("mcmc_output")
View(data_list)
View(data_list)
install.packages("spdep")
install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/testing"), dep=TRUE)
remotes::install_github("inlabru-org/inlabru")
round(df$BI_aegypti),0)
uf_df <- data.frame(
"N"  = I(list(
c("AC", "AP", "AM", "PA", "RO", "RR", "TO")
)),
"NE" = I(list(
c("AL", "BA", "CE", "MA", "PB", "PE", "PI", "RN", "SE")
)),
"CW" = I(list(c(
"DF", "GO", "MT", "MS"
))),
"SE" = I(list(c(
"ES", "MG", "RJ", "SP"
))),
"S"  = I(list(c("PR", "RS", "SC")))
)
View(uf_df)
uf_df
uf_ls <- c()
for (i in region) {
uf_ls_temp <- unlist(uf_df[i])
uf_ls <- c(uf_ls, uf_ls_temp)
}
20*20
1/188.3
36/12
0.7*0.7
library(xaringan)
library(sf)
library(remotes)
remotes::install_github("geocompr/geocompkg",
upgrade = "ask", dependencies = TRUE, force = TRUE)
remotes::install_github("nowosad/spDataLarge")
warning()
warnings()
warnings()
remotes::install_github("nowosad/spDataLarge")
library(terra)
remotes::install_github("nowosad/spDataLarge")
library(spDataLarge)
remotes::install_github("jhelvy/renderthis", force=TRUE)
remotes::install_github('rstudio/chromote')
install.packages("webshot2")
library(renderthis)
library(webshot2)
library(xaringan)
# rmarkdown
install.packages("rmarkdown", dep = TRUE)
# xaringan
remotes::install_github('yihui/xaringan')
# xaringan
remotes::install_github('yihui/xaringan')
install.packages("cli")
install.packages("cli")
install.packages("cli")
install.packages("cli")
install.packages("cli")
library()
install.packages("cli")
library(devtools)
install.packages("cli")
install.packages("cli")
install.packages("cli")
remove.packages(xaringan)
remove.packages("rmarkdown")
remove.packages("xaringan")
remotes::install_github("mitchelloharawild/icons")
install.packages("tikzDevice")
install.packages("kableExtra")
install.packages("dplyr")
install.packages("shiny")
install.packages("RefManageR")
library()
remotes::install_github("gadenbuie/xaringanExtra")
install.packages("servr")
install.packages("kableExtra")
library(xaringan)
library(xaringanExtra)
.libPaths()
1500*3
150*4
600*3
4500+1800
4*130
520*3
6300+2500
10-8800
10000-8800
1500*2
150*4*2
3000+1200
52.4/10.1
52.4^2/10.1
5.18*5.18
26.8*10.1
(52.4*52.4)/10.1
52.4/1000
271.85/1000
knitr::opts_chunk$set(echo = TRUE)
library(gstat)
# We use Meuse dataset, which includes concentrations of zinc
# measured at 155 sampling sites within the Meuse River plain
data(meuse)
library(sp)
library(gstat)
# We use Meuse dataset, which includes concentrations of zinc
# measured at 155 sampling sites within the Meuse River plain
data(meuse)
# Transform the dataframe into a SpatialPointDataFrame
coordinates(meuse) = ~x+y # the function coordinates
# promotes the data.frame meuse
# into a SpatialPointsDataFrame
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
# Construct the variogram
meuse.vgm = variogram(log(zinc)~1, meuse) # we assume a constant trend for
# the variable log(zinc)
# Plot the experimental variogram
plot(meuse.vgm)
plot(meuse.vgm, plot.numbers = TRUE, pch = "+") # The numbers of points in the
# lag group used to compute the corresponding value of gamma(h)
# Fit a variogram model
model.1 = fit.variogram(meuse.vgm, vgm("Sph"))
plot(meuse.vgm, model=model.1)
# Look at the result of the fit
model.1
# We can also specify a set of models. In this case the best fitting is returned
model.2 = fit.variogram(meuse.vgm, vgm(c("Exp", "Sph")))
model.2 # here the spherical model with nugget=0.051, partial sill =0.591 and range=897 is chosen
# Specify theoretical variogram with its characteristics
model.final = fit.variogram(meuse.vgm, vgm(psill=0.59,"Sph",range=897,nugget=0.05))
plot(meuse.vgm, model=model.final)
# We use Meuse dataset, which includes concentrations of zinc
# measured at 155 sampling sites within the Meuse River plain
data(meuse)
View(meuse)
# Transform the dataframe into a SpatialPointDataFrame
coordinates(meuse) = ~x+y # the function coordinates
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
hist(meuse$zinc) # we see a strong right skew in the data, so we log-transform them
hist(meuse$zinc) # we see a strong right skew in the data, so we log-transform them
# Lagged scatter plot
hscat(log(zinc)~1, meuse,(0:9)*100) # the correlation is quite strong when the lag
# We use Meuse dataset, which includes concentrations of zinc
# measured at 155 sampling sites within the Meuse River plain
data(meuse)
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
# Transform the dataframe into a SpatialPointDataFrame
coordinates(meuse) = ~x+y # the function coordinates
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
hist(meuse$zinc) # we see a strong right skew in the data, so we log-transform them
# Lagged scatter plot
hscat(log(zinc)~1, meuse,(0:9)*100) # the correlation is quite strong when the lag
# Construct the variogram
meuse.vgm = variogram(log(zinc)~1, meuse) # we assume a constant trend for
# Plot the experimental variogram
plot(meuse.vgm)
plot(meuse.vgm, plot.numbers = TRUE, pch = "+") # The numbers of points in the
lot(meuse.vgm, plot.numbers = TRUE, pch = "+") #
plot(meuse.vgm, plot.numbers = TRUE, pch = "+") #
# Construct the variogram
meuse.vgm = variogram(log(zinc)~1, meuse) # we assume a constant trend for
plot(meuse.vgm, plot.numbers = TRUE, pch = "+") # The numbers of points in the
# Fit a variogram model
model.1 = fit.variogram(meuse.vgm, vgm("Sph"))
plot(meuse.vgm, model=model.1)
# Look at the result of the fit
model.1
model.final = fit.variogram(meuse.vgm, vgm(psill=0.59,"Sph",range=897,nugget=0.05))
plot(meuse.vgm, model=model.final)
View(meuse)
head(meuse)
# We use Meuse dataset, which includes concentrations of zinc
# measured at 155 sampling sites within the Meuse River plain
data(meuse)
head(meuse)
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
# Transform the dataframe into a SpatialPointDataFrame
# the function coordinates promotes the data.frame meuse into a SpatialPointsDataFrame
coordinates(meuse) = ~x+y
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
hist(meuse$zinc) # we see a strong right skew in the data, so we log-transform them
# Lagged scatter plot
hscat(log(zinc)~1, meuse,(0:9)*100) # the correlation is quite strong when the lag
# Construct the variogram
meuse.vgm = variogram(log(zinc)~1, meuse) # we assume a constant trend for
# Plot the experimental variogram
plot(meuse.vgm)
plot(meuse.vgm, plot.numbers = TRUE, pch = "+") # The numbers of points in the
# Fit a variogram model
model.1 = fit.variogram(meuse.vgm, vgm("Sph"))
plot(meuse.vgm, model=model.1)
# We can also specify a set of models. In this case the best fitting is returned
model.2 = fit.variogram(meuse.vgm, vgm(c("Exp", "Sph")))
model.2 # here the spherical model with nugget=0.051, partial sill =0.591 and range=897 is chosen
model.final = fit.variogram(meuse.vgm, vgm(psill=0.59,"Sph",range=897,nugget=0.05))
plot(meuse.vgm, model=model.final)
setwd("C:/Users/Monica/Dropbox/TEACHING/YEAR_2023/Bayes_Spatial_2023/Material/Session6")
library(xaringan)
library(xaringanExtra)
library(renderthis)
library(webshot2)
to_pdf(from = "index.html", partial_slides = TRUE)
setwd("C:/Users/Monica/Dropbox/TEACHING/YEAR_2023/Bayes_Spatial_2023/Material/Practical3a")
setwd("C:/Users/Monica/Dropbox/TEACHING/YEAR_2023/Bayes_Spatial_2023/Material/Practical6a")
getwd()
setwd("C:/Users/Monica/Dropbox/TEACHING/YEAR_2023/Bayes_Spatial_2023/Material/Practical3b")
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE, fig.align = "center", class.source='klippy')
# Chunk 2: klippy
klippy::klippy(position = c('top', 'right'),color = 'darkred',
tooltip_message = 'Click to copy', tooltip_success = 'Done')
# Chunk 6
library(INLA)         # Integrated Nested Laplace Approximation package
library(dplyr)        # A package for data manipulation
library(sf)           # Simple feature for R
library(spdep)        # Functions and tests for evaluating spatial patterns
# and autocorrelation
# Packages used for visualization
library(RColorBrewer) # A package providing colour palettes for shading maps
# and other plots
library(tmap)         # A package for static and interactive maps
library(ggplot2)      # A package that implements the grammar of graphics, which is a term used to
# break up graphs into semantic components, such as geometries and layers.
library(mapview)      # A package for interactive maps
library(cowplot)      # Add-on to ggplot. It provides features that help us with creating
# publication-quality figures
# Chunk 7
LTLA = st_read("LTLA_shp.shp")
getwd()
library(INLA)         # Integrated Nested Laplace Approximation package
library(dplyr)        # A package for data manipulation
library(sf)           # Simple feature for R
library(spdep)        # Functions and tests for evaluating spatial patterns
# and autocorrelation
# Packages used for visualization
library(RColorBrewer) # A package providing colour palettes for shading maps
# and other plots
library(tmap)         # A package for static and interactive maps
library(ggplot2)      # A package that implements the grammar of graphics, which is a term used to
# break up graphs into semantic components, such as geometries and layers.
library(mapview)      # A package for interactive maps
library(cowplot)      # Add-on to ggplot. It provides features that help us with creating
LTLA = st_read("LTLA_shp.shp")
getwd()
setwd("C:/Users/Monica/Dropbox/TEACHING/YEAR_2023/Bayes_Spatial_2023/Material/Practical6b")
LTLA = st_read("LTLA_shp.shp")
library(rmarkdown)
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE, fig.align = "center", class.source='klippy')
# Chunk 2: klippy
klippy::klippy(position = c('top', 'right'),color = 'darkred',
tooltip_message = 'Click to copy', tooltip_success = 'Done')
# Chunk 6
library(INLA)         # Integrated Nested Laplace Approximation package
library(dplyr)        # A package for data manipulation
library(sf)           # Simple feature for R
library(spdep)        # Functions and tests for evaluating spatial patterns
# and autocorrelation
# Packages used for visualization
library(RColorBrewer) # A package providing colour palettes for shading maps
# and other plots
library(tmap)         # A package for static and interactive maps
library(ggplot2)      # A package that implements the grammar of graphics, which is a term used to
# break up graphs into semantic components, such as geometries and layers.
library(mapview)      # A package for interactive maps
library(cowplot)      # Add-on to ggplot. It provides features that help us with creating
# publication-quality figures
# Chunk 7
LTLA = st_read("LTLA_shp.shp")
class(LTLA)
# Chunk 10
ggplot() +
geom_sf(data = LTLA, color = "red", fill = "white") +
ggtitle("Map of LTLAs in England") +
coord_sf() +    #axis limits and CRS
labs(x = "Longitude", y = "Latitude", fill = "") +
theme_bw() +    # dark-on-light theme
theme(axis.title = element_text(size = 16),
axis.text = element_text(size = 14))
# Chunk 11: LTLA_map
tm_shape(LTLA) +
tm_fill("tomato") +
tm_borders(lty="dashed", col="gold") +
tm_style("natural", bg.color="grey90") +
tm_layout(title="Map of LTLAs in England")
# Chunk 12
# as seen before, but with specified presentation mode
tmap_mode("plot")
tm_shape(LTLA) +
tm_fill("grey90") +
tm_borders(lty="solid", col="skyblue1") +
tm_style("albatross") +
tm_layout(title="Static Map of LTLAs in England")
# Chunk 13
# interactive mode
tmap_mode("view")
tm_shape(LTLA) +
tm_fill("grey90") +
tm_borders(lty="solid", col="black") +
tm_style("natural") +
tm_layout(title="Interactive Map of LTLAs in England")
# Chunk 14
mapview(LTLA, legend = FALSE)
# Chunk 15
COVID19Deaths = read.csv("COVID19Deaths.csv", header = TRUE)
# Chunk 16
COVID19Deaths$SMR = COVID19Deaths$O/COVID19Deaths$E
# Chunk 17
names(LTLA)
names(COVID19Deaths)
England_SMR = left_join(LTLA, COVID19Deaths, by = c("LTLA" = "LTLA"))
# Chunk 18
plot(England_SMR["O"])
# Chunk 19
plot(England_SMR["SMR"], breaks = c(0,0.5,1,1.5,2))
# Chunk 21: SMR_map
tmap_mode("plot")
tm_shape(England_SMR) + tm_polygons("SMR",palette="RdYlGn", style="cont", n=8) +
tm_borders(lty="solid", col="black") +
tm_style("natural") +
tm_layout(title="Map of SMRs at LTLA level in England")
# Chunk 22: IMD_map
tmap_mode("plot")
tm_shape(England_SMR) + tm_polygons("IMD",style="pretty", n=8, alpha=0.5) +
tm_borders(lty="solid", col="black") +
tm_style("natural") +
tm_layout(title="Map of IMD at LTLA level in England")
# Chunk 23
display.brewer.all()
# Chunk 24
breaks =  c(0,0.5,1,1.5,2)
England_SMR = mutate(England_SMR, SMR_cat = cut(SMR, breaks, include.lowest = TRUE)) # mutate() adds new variables and preserves existing ones
ggplot() + geom_sf(data = England_SMR, aes(fill = SMR_cat), col = NA) +
theme_bw() + scale_fill_brewer(palette = "OrRd") +
guides(fill=guide_legend(title="SMR"))
# Chunk 25
names(inla.models()$latent$iid$hyper)
# Chunk 26
inla.models()$latent$iid$hyper$theta$name
# Chunk 27
inla.models()$latent$iid$hyper$theta$short.name
# Chunk 28: INLA_iid
ID = seq(1,317)
# we define a Gamma prior on the precision of a iid model with parameters
# 0.01 and 0.01
prec.prior = list(prec = list(prior = "loggamma", param = c(0.01, 0.01)))
formula_iid = O ~ f(ID, model="iid", hyper = prec.prior)
mod_iid = inla(formula=formula_iid, family="poisson", data=England_SMR, E=E, control.compute=list(dic=TRUE, waic=TRUE))
# Chunk 29
mod_iid$waic$waic
mod_iid$dic$dic
# Chunk 30: INLA_reg
formula_reg = O ~ IMD + f(ID, model="iid", hyper = prec.prior)
mod_reg = inla(formula=formula_reg, family="poisson", data=England_SMR, E=E, control.compute=list(dic=TRUE, waic=TRUE))
mod_reg$waic$waic
mod_reg$dic$dic
# Chunk 31
RR_COVID = c()
for(i in 1:317){
RR_COVID[i] = inla.emarginal(function(x) exp(x),
mod_iid$marginals.random$ID[[i]])
}
# Chunk 32
England_SMR$RR = RR_COVID
MapRR1 = ggplot() + geom_sf(data = England_SMR, aes(fill = RR), col = NA) + theme_bw() +
scale_fill_viridis_c(limits = c(0,2))
MapRR1
plot_grid(MapSMR1, MapRR1, ncol = 1, align = 'v', labels="AUTO", rel_widths = c(1, 1))
MapSMR1
MapSMR1 = ggplot() +
geom_sf(data = England_SMR, aes(fill = SMR), col = NA) +
scale_fill_viridis_c(limits = c(0,2)) + theme_bw()
MapSMR1
