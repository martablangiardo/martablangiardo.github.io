Do this later                 :               first_3,    after first_2, 5d
Do this after that            :               first_4,    after first_3, 5d
section Interventions
Completed, critical task      :crit, done,    import_1,   2014-01-06,24h
Also done, also critical      :crit, done,    import_2,   after import_1, 2d
Doing this important task now :crit, active,  import_3,   after import_2, 3d
Next critical task            :crit,          import_4,   after import_3, 5d
section Post-intervention
First extras                  :active,        extras_1,   after import_4,  3d
Second helping                :               extras_2,   after extras_1, 20h
More of the extras            :               extras_3,   after extras_1, 48h
")
150*7
80*7
1050+560+1600+100
3500*4
50*7
350+50+1600+560+1050
3610*4
36+12
3600*2
8/4
80*7
500+300+100+200+100
1200*4
300000+70000+50000
55*2*8
880+880
1000/48
500?28
500/28
55*2*9
990+990
55*2*0.2
32*0.2
55*2*18
2010-1997
3000*5
3000*4
12000+3000+6000
12000+3000+3000
2000*9
3000*6
12*4
55*9*2
35*5*2
350+990
1340*2
12-700
12000-7000
11-2.5
7.5+3.5
1088*5
1500*12
430000-60000
1.5+3.5+1+1+1
library("bayesmix")
install.packages("bayesmix")
library("bayesmix")
data("fish", package = "bayesmix")
x <- fish[ , 1]
n <- length(x)
K <- 5
m <- 11000
burn <- 1000
model <- BMMmodel(fish, k = K, initialValues = list(S0 = 2),
+ priors = list(kind = "independence", parameter = "priorsFish",
+ hierarchical = "tau"))
model <- BMMmodel(fish, k = K, initialValues = list(S0 = 2),
priors = list(kind = "independence", parameter = "priorsFish",
hierarchical = "tau"))
model <- BMMmodel(fish, k = 4, priors = list(kind = "independence",
parameter = "priorsFish", hierarchical = "tau"),
initialValues = list(S0 = 2))
library("bayesmix")
library("bayesmix")
model <- BMMmodel(fish, k = K, initialValues = list(S0 = 2),
priors = list(kind = "independence",
parameter = "priorsFish",
hierarchical = "tau"))
control <- JAGScontrol(variables = c("mu", "tau", "eta", "S"),
burn.in = burn, n.iter = m, seed = 10)
mcmc <- JAGSrun(fish, model = model, control = control)
View(mcmc)
help(print.JAGSmodel)
head(fish)
J <- 3
mcmc.pars <- array(data = NA, dim = c(m, K, J))
mcmc.pars[ , , 1] <- mcmc$results[-(1:burn), (n+K+1):(n+2*K)]
mcmc.pars[ , , 2] <- mcmc$results[-(1:burn), (n+2*K+1):(n+3*K)]
J <- 3
mcmc.pars <- array(data = NA, dim = c(m, K, J))
mcmc.pars[ , , 3] <- mcmc$results[-(1:burn), (n+1):(n+K)]
z <- mcmc$results[-(1:burn), 1:n]
mcmc$results
mcmc.pars[ , , 1] <- mcmc$results[-(1:burn), (n+K+1):(n+2*K)]
View(z)
p <- array(data = NA, dim = c(m, n, K))
for (iter in 1:m){
for(i in 1:n){
kdist <- mcmc.pars[iter, , 3]*dnorm(x[i], mcmc.pars[iter, , 1],
+ sqrt(mcmc.pars[iter, , 2]))
skdist <- sum(kdist)
for(j in 1:K){
p[iter, i, j] = kdist[j]/skdist}}}
p
dim(p)
#load a toy example: MCMC output consists of the random beta model
# applied to a normal mixture of \code{K=2} components. The number
# of observations is equal to \code{n=5}. The number of MCMC samples
# is equal to \code{m=300}. The matrix of allocation probabilities
# is stored to matrix \code{p}.
data("mcmc_output")
data("mcmc_output", package = "bayesmix)
# mcmc parameters are stored to array \code{mcmc.pars}
mcmc.pars<-data_list$"mcmc.pars"
# mcmc.pars[,,1]: simulated means of the two components
# mcmc.pars[,,2]: simulated variances
# mcmc.pars[,,3]: simulated weights
# the computed allocation matrix is p
p<-data_list$"p"
run<-stephens(p)
# apply the permutations returned by typing:
reordered.mcmc<-permute.mcmc(mcmc.pars,run$permutations)
# reordered.mcmc[,,1]: reordered means of the components
# reordered.mcmc[,,2]: reordered variances
# reordered.mcmc[,,3]: reordered weights
data("mcmc_output", package = "bayesmix")
library("label.switching")
data("mcmc_output")
# mcmc parameters are stored to array \code{mcmc.pars}
mcmc.pars<-data_list$"mcmc.pars"
mcmc.pars[,,1]: simulated means of the two components
mcmc_output
data("mcmc_output")
data("mcmc_output")
View(data_list)
View(data_list)
install.packages("spdep")
install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/testing"), dep=TRUE)
remotes::install_github("inlabru-org/inlabru")
round(df$BI_aegypti),0)
uf_df <- data.frame(
"N"  = I(list(
c("AC", "AP", "AM", "PA", "RO", "RR", "TO")
)),
"NE" = I(list(
c("AL", "BA", "CE", "MA", "PB", "PE", "PI", "RN", "SE")
)),
"CW" = I(list(c(
"DF", "GO", "MT", "MS"
))),
"SE" = I(list(c(
"ES", "MG", "RJ", "SP"
))),
"S"  = I(list(c("PR", "RS", "SC")))
)
View(uf_df)
uf_df
uf_ls <- c()
for (i in region) {
uf_ls_temp <- unlist(uf_df[i])
uf_ls <- c(uf_ls, uf_ls_temp)
}
20*20
1/188.3
36/12
0.7*0.7
library(xaringan)
library(sf)
library(remotes)
remotes::install_github("geocompr/geocompkg",
upgrade = "ask", dependencies = TRUE, force = TRUE)
remotes::install_github("nowosad/spDataLarge")
warning()
warnings()
warnings()
remotes::install_github("nowosad/spDataLarge")
library(terra)
remotes::install_github("nowosad/spDataLarge")
library(spDataLarge)
remotes::install_github("jhelvy/renderthis", force=TRUE)
remotes::install_github('rstudio/chromote')
install.packages("webshot2")
library(renderthis)
library(webshot2)
library(xaringan)
# rmarkdown
install.packages("rmarkdown", dep = TRUE)
# xaringan
remotes::install_github('yihui/xaringan')
# xaringan
remotes::install_github('yihui/xaringan')
install.packages("cli")
install.packages("cli")
install.packages("cli")
install.packages("cli")
install.packages("cli")
library()
install.packages("cli")
library(devtools)
install.packages("cli")
install.packages("cli")
install.packages("cli")
remove.packages(xaringan)
remove.packages("rmarkdown")
remove.packages("xaringan")
remotes::install_github("mitchelloharawild/icons")
install.packages("tikzDevice")
install.packages("kableExtra")
install.packages("dplyr")
install.packages("shiny")
install.packages("RefManageR")
library()
remotes::install_github("gadenbuie/xaringanExtra")
install.packages("servr")
install.packages("kableExtra")
library(xaringan)
library(xaringanExtra)
.libPaths()
1500*3
150*4
600*3
4500+1800
4*130
520*3
6300+2500
10-8800
10000-8800
1500*2
150*4*2
3000+1200
52.4/10.1
52.4^2/10.1
5.18*5.18
26.8*10.1
(52.4*52.4)/10.1
52.4/1000
271.85/1000
knitr::opts_chunk$set(echo = TRUE)
library(gstat)
# We use Meuse dataset, which includes concentrations of zinc
# measured at 155 sampling sites within the Meuse River plain
data(meuse)
library(sp)
library(gstat)
# We use Meuse dataset, which includes concentrations of zinc
# measured at 155 sampling sites within the Meuse River plain
data(meuse)
# Transform the dataframe into a SpatialPointDataFrame
coordinates(meuse) = ~x+y # the function coordinates
# promotes the data.frame meuse
# into a SpatialPointsDataFrame
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
# Construct the variogram
meuse.vgm = variogram(log(zinc)~1, meuse) # we assume a constant trend for
# the variable log(zinc)
# Plot the experimental variogram
plot(meuse.vgm)
plot(meuse.vgm, plot.numbers = TRUE, pch = "+") # The numbers of points in the
# lag group used to compute the corresponding value of gamma(h)
# Fit a variogram model
model.1 = fit.variogram(meuse.vgm, vgm("Sph"))
plot(meuse.vgm, model=model.1)
# Look at the result of the fit
model.1
# We can also specify a set of models. In this case the best fitting is returned
model.2 = fit.variogram(meuse.vgm, vgm(c("Exp", "Sph")))
model.2 # here the spherical model with nugget=0.051, partial sill =0.591 and range=897 is chosen
# Specify theoretical variogram with its characteristics
model.final = fit.variogram(meuse.vgm, vgm(psill=0.59,"Sph",range=897,nugget=0.05))
plot(meuse.vgm, model=model.final)
# We use Meuse dataset, which includes concentrations of zinc
# measured at 155 sampling sites within the Meuse River plain
data(meuse)
View(meuse)
# Transform the dataframe into a SpatialPointDataFrame
coordinates(meuse) = ~x+y # the function coordinates
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
hist(meuse$zinc) # we see a strong right skew in the data, so we log-transform them
hist(meuse$zinc) # we see a strong right skew in the data, so we log-transform them
# Lagged scatter plot
hscat(log(zinc)~1, meuse,(0:9)*100) # the correlation is quite strong when the lag
# We use Meuse dataset, which includes concentrations of zinc
# measured at 155 sampling sites within the Meuse River plain
data(meuse)
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
# Transform the dataframe into a SpatialPointDataFrame
coordinates(meuse) = ~x+y # the function coordinates
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
hist(meuse$zinc) # we see a strong right skew in the data, so we log-transform them
# Lagged scatter plot
hscat(log(zinc)~1, meuse,(0:9)*100) # the correlation is quite strong when the lag
# Construct the variogram
meuse.vgm = variogram(log(zinc)~1, meuse) # we assume a constant trend for
# Plot the experimental variogram
plot(meuse.vgm)
plot(meuse.vgm, plot.numbers = TRUE, pch = "+") # The numbers of points in the
lot(meuse.vgm, plot.numbers = TRUE, pch = "+") #
plot(meuse.vgm, plot.numbers = TRUE, pch = "+") #
# Construct the variogram
meuse.vgm = variogram(log(zinc)~1, meuse) # we assume a constant trend for
plot(meuse.vgm, plot.numbers = TRUE, pch = "+") # The numbers of points in the
# Fit a variogram model
model.1 = fit.variogram(meuse.vgm, vgm("Sph"))
plot(meuse.vgm, model=model.1)
# Look at the result of the fit
model.1
model.final = fit.variogram(meuse.vgm, vgm(psill=0.59,"Sph",range=897,nugget=0.05))
plot(meuse.vgm, model=model.final)
View(meuse)
head(meuse)
# We use Meuse dataset, which includes concentrations of zinc
# measured at 155 sampling sites within the Meuse River plain
data(meuse)
head(meuse)
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
# Transform the dataframe into a SpatialPointDataFrame
# the function coordinates promotes the data.frame meuse into a SpatialPointsDataFrame
coordinates(meuse) = ~x+y
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
hist(meuse$zinc) # we see a strong right skew in the data, so we log-transform them
# Lagged scatter plot
hscat(log(zinc)~1, meuse,(0:9)*100) # the correlation is quite strong when the lag
# Construct the variogram
meuse.vgm = variogram(log(zinc)~1, meuse) # we assume a constant trend for
# Plot the experimental variogram
plot(meuse.vgm)
plot(meuse.vgm, plot.numbers = TRUE, pch = "+") # The numbers of points in the
# Fit a variogram model
model.1 = fit.variogram(meuse.vgm, vgm("Sph"))
plot(meuse.vgm, model=model.1)
# We can also specify a set of models. In this case the best fitting is returned
model.2 = fit.variogram(meuse.vgm, vgm(c("Exp", "Sph")))
model.2 # here the spherical model with nugget=0.051, partial sill =0.591 and range=897 is chosen
model.final = fit.variogram(meuse.vgm, vgm(psill=0.59,"Sph",range=897,nugget=0.05))
plot(meuse.vgm, model=model.final)
library("spatstat")
library("sp")
library("maptools")
data(bei)
# Create SpatialPoints object
bei.pts <- as(bei, "SpatialPoints")
#Create grid
bei.poly <- as(as.im(bei$window, dimyx=c(5, 10)), "SpatialGridDataFrame")
bei.poly <- as(bei.poly, "SpatialPolygons")
idx <- over(bei.pts, bei.poly)
tab.idx <- table(idx)
#Add number of trees
d <- data.frame(Ntrees = rep(0, length(bei.poly)))
row.names(d) <- paste0("g", 1:length(bei.poly))
d$Ntrees[as.integer(names(tab.idx))] <- tab.idx
bei.trees <- SpatialPolygonsDataFrame(bei.poly, d)
#Mapping
idx.mapping <- as.vector(t(matrix(1:50, nrow = 10, ncol = 5)))
bei.trees2 <- bei.trees[idx.mapping, ]
devtools::install_github('Keefe-Murphy/IMIFA')
library(IMIFA)
data("olive")
force(olive)
simmary(olive)
summary(olive)
data(USPSdigits)
summary(USPSdigits)
?USPSdigits
simMFA   <- mcmc_IMIFA(olive, method="MFA", n.iters=10000, range.G=3:6, range.Q=0:3, centering=FALSE,
scaling="unit", uni.type="isotropic", score.switch=FALSE)
simMFA  = mcmc_IMIFA(olive, method="MFA", n.iters=10000, range.G=3:6,
range.Q=0:3, centering=FALSE,
scaling="unit", uni.type="isotropic",
score.switch=FALSE)
simMFA  = mcmc_IMIFA(olive, method="MFA", n.iters=10000, range.G=0,
range.Q=0:3, centering=FALSE,
scaling="unit", uni.type="isotropic",
score.switch=FALSE)
simMFA  = mcmc_IMIFA(olive, method="MFA", n.iters=10000, range.G=0:2,
range.Q=0:3, centering=FALSE,
scaling="unit", uni.type="isotropic",
score.switch=FALSE)
simMFA  = mcmc_IMIFA(olive, method="MFA", n.iters=10000, range.G=3:6,
range.Q=0:3, centering=FALSE,
scaling="unit", uni.type="isotropic",
score.switch=FALSE)
simMIFA  <- mcmc_IMIFA(olive, method="MIFA", n.iters=10000, centering=TRUE,
range.G=1:3, z.init="kmeans")
54000/12
54000/12
55000/12
load("~/Downloads/ocean (1).Rdata")
View(train)
View(hold_out)
View(train)
library(INLA)
n=203
n.seas=12
trend=1:n
seasonal.sim=rep(1:n.seas, ceiling(n/n.seas))[1:n]
seasonal.sim
install.packages("spdep")
inla.doc("ar1")
library(INLA)
inla.doc("ar1")
install.packages('rmarkdown')
remotes::install_github('yihui/xaringan')
46734/12
15000/500
413565+78060.80+17303.20
46028+309529+44559.28
(400116*100)/909045.70
#library(maps)
library(INLA)
install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/testing"), dep=TRUE)
install.packages("Rgraphviz")
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("Rgraphviz")
install.packages("dplyr")
install.packages("graph")
BiocManager::install("graph")
# Remove Package
remove.packages("INLA")
install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
library(INLA)
install.packages("geostatsp")
library(INLA)
sessionInfo()
library(leaflet)
popup = c("Monica", "Marta", "Georges", "Abi", "Connor")
leaflet() |>
addProviderTiles("NASAGIBS.ViirsEarthAtNight2012") |>
addMarkers(lng = c(41, -3, 2),
lat = c(12, 52, 30),
popup = popup)
popup = c("Monica", "Marta", "Georges", "Abi", "Connor")
leaflet() |>
addProviderTiles("NASAGIBS.ViirsEarthAtNight2012") |>
addMarkers(lng = c(42, -3, 2),
lat = c(12, 52, 30),
popup = popup)
popup = "Imperial College London"
leaflet() |>
setView(51.488064, -0.172471, zoom=4) |>
addProviderTiles("NASAGIBS.ViirsEarthAtNight2012
addMarkers(lng = 51.488064,
lat = -0.172471,
popup = popup)
0
?
popup = "Imperial College London"
leaflet() |>
setView(51.488064, -0.172471, zoom=4) |>
addProviderTiles("NASAGIBS.ViirsEarthAtNight2012") |>
addMarkers(lng = 51.488064,
lat = -0.172471,
popup = popup)
library(leaflet)
popup = "Imperial College London"
leaflet() |>
setView(51.488064, -0.172471, zoom=4) |>
addProviderTiles("NASAGIBS.ViirsEarthAtNight2012") |>
addMarkers(lng = 51.488064,
lat = -0.172471,
popup = popup)
popup = "Imperial College London"
leaflet() |>
setView(51.488064, -0.172471, zoom=4) |>
addProviderTiles("NASAGIBS.ViirsEarthAtNight2012") |>
addMarkers(lng = -0.172471,
lat = 51.488064,
popup = popup)
popup = "Imperial College London"
leaflet() |>
setView(-0.172471, 51.488064, zoom=4) |>
addProviderTiles("NASAGIBS.ViirsEarthAtNight2012") |>
addMarkers(lng = -0.172471,
lat = 51.488064,
popup = popup)
set.seed(1234) #set the seed
n = 100
sigma = 0.1
beta.0 =  2
beta.1 = 0.5
x = runif(n)
eta = beta.0 +  beta.1*x
y = rnorm(n,eta,sigma)
#plot(x,y) #plot the data
my.data = data.frame(y=y,x=x)
library(INLA)
inla.list.models()
inla.list.models()$latent
names(inla.list.models()$latent)
names(inla.models()$latent)
25-100
(75*75)
1350*4
5625-5400
sqrt(225)
35*4
sqrt(144)
setwd("C:/Users/Monica/Dropbox/TEACHING/YEAR_2024/Bayes_Spatial_2024/Material/Session7")
library(renderthis)
to_pdf(from = "index.Rmd", partial_slides = TRUE)
