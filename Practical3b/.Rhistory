dateFormat  YYYY-MM-DD
title A Very Nice Gantt Diagram
section Pre-intervention
This is completed             :done,          first_1,    2014-01-06, 2014-01-08
This is active                :active,        first_2,    2014-01-09, 3d
Do this later                 :               first_3,    after first_2, 5d
Do this after that            :               first_4,    after first_3, 5d
section Interventions
Completed, critical task      :crit, done,    import_1,   2014-01-06,24h
Also done, also critical      :crit, done,    import_2,   after import_1, 2d
Doing this important task now :crit, active,  import_3,   after import_2, 3d
Next critical task            :crit,          import_4,   after import_3, 5d
section Post-intervention
First extras                  :active,        extras_1,   after import_4,  3d
Second helping                :               extras_2,   after extras_1, 20h
More of the extras            :               extras_3,   after extras_1, 48h
")
mermaid("
gantt
dateFormat  YYYY-MM-DD
Research intervention timeline
section Pre-intervention
This is completed             :done,          first_1,    2014-01-06, 2014-01-08
This is active                :active,        first_2,    2014-01-09, 3d
Do this later                 :               first_3,    after first_2, 5d
Do this after that            :               first_4,    after first_3, 5d
section Interventions
Completed, critical task      :crit, done,    import_1,   2014-01-06,24h
Also done, also critical      :crit, done,    import_2,   after import_1, 2d
Doing this important task now :crit, active,  import_3,   after import_2, 3d
Next critical task            :crit,          import_4,   after import_3, 5d
section Post-intervention
First extras                  :active,        extras_1,   after import_4,  3d
Second helping                :               extras_2,   after extras_1, 20h
More of the extras            :               extras_3,   after extras_1, 48h
")
mermaid("
gantt
dateFormat  YYYY-MM-DD
title Gantt Diagram
section Pre-intervention
This is completed             :done,          first_1,    2014-01-06, 2014-01-08
This is active                :active,        first_2,    2014-01-09, 3d
Do this later                 :               first_3,    after first_2, 5d
Do this after that            :               first_4,    after first_3, 5d
section Interventions
Completed, critical task      :crit, done,    import_1,   2014-01-06,24h
Also done, also critical      :crit, done,    import_2,   after import_1, 2d
Doing this important task now :crit, active,  import_3,   after import_2, 3d
Next critical task            :crit,          import_4,   after import_3, 5d
section Post-intervention
First extras                  :active,        extras_1,   after import_4,  3d
Second helping                :               extras_2,   after extras_1, 20h
More of the extras            :               extras_3,   after extras_1, 48h
")
150*7
80*7
1050+560+1600+100
3500*4
50*7
350+50+1600+560+1050
3610*4
36+12
3600*2
8/4
80*7
500+300+100+200+100
1200*4
300000+70000+50000
55*2*8
880+880
1000/48
500?28
500/28
55*2*9
990+990
55*2*0.2
32*0.2
55*2*18
2010-1997
3000*5
3000*4
12000+3000+6000
12000+3000+3000
2000*9
3000*6
12*4
55*9*2
35*5*2
350+990
1340*2
12-700
12000-7000
11-2.5
7.5+3.5
1088*5
1500*12
430000-60000
1.5+3.5+1+1+1
library("bayesmix")
install.packages("bayesmix")
library("bayesmix")
data("fish", package = "bayesmix")
x <- fish[ , 1]
n <- length(x)
K <- 5
m <- 11000
burn <- 1000
model <- BMMmodel(fish, k = K, initialValues = list(S0 = 2),
+ priors = list(kind = "independence", parameter = "priorsFish",
+ hierarchical = "tau"))
model <- BMMmodel(fish, k = K, initialValues = list(S0 = 2),
priors = list(kind = "independence", parameter = "priorsFish",
hierarchical = "tau"))
model <- BMMmodel(fish, k = 4, priors = list(kind = "independence",
parameter = "priorsFish", hierarchical = "tau"),
initialValues = list(S0 = 2))
library("bayesmix")
library("bayesmix")
model <- BMMmodel(fish, k = K, initialValues = list(S0 = 2),
priors = list(kind = "independence",
parameter = "priorsFish",
hierarchical = "tau"))
control <- JAGScontrol(variables = c("mu", "tau", "eta", "S"),
burn.in = burn, n.iter = m, seed = 10)
mcmc <- JAGSrun(fish, model = model, control = control)
View(mcmc)
help(print.JAGSmodel)
head(fish)
J <- 3
mcmc.pars <- array(data = NA, dim = c(m, K, J))
mcmc.pars[ , , 1] <- mcmc$results[-(1:burn), (n+K+1):(n+2*K)]
mcmc.pars[ , , 2] <- mcmc$results[-(1:burn), (n+2*K+1):(n+3*K)]
J <- 3
mcmc.pars <- array(data = NA, dim = c(m, K, J))
mcmc.pars[ , , 3] <- mcmc$results[-(1:burn), (n+1):(n+K)]
z <- mcmc$results[-(1:burn), 1:n]
mcmc$results
mcmc.pars[ , , 1] <- mcmc$results[-(1:burn), (n+K+1):(n+2*K)]
View(z)
p <- array(data = NA, dim = c(m, n, K))
for (iter in 1:m){
for(i in 1:n){
kdist <- mcmc.pars[iter, , 3]*dnorm(x[i], mcmc.pars[iter, , 1],
+ sqrt(mcmc.pars[iter, , 2]))
skdist <- sum(kdist)
for(j in 1:K){
p[iter, i, j] = kdist[j]/skdist}}}
p
dim(p)
#load a toy example: MCMC output consists of the random beta model
# applied to a normal mixture of \code{K=2} components. The number
# of observations is equal to \code{n=5}. The number of MCMC samples
# is equal to \code{m=300}. The matrix of allocation probabilities
# is stored to matrix \code{p}.
data("mcmc_output")
data("mcmc_output", package = "bayesmix)
# mcmc parameters are stored to array \code{mcmc.pars}
mcmc.pars<-data_list$"mcmc.pars"
# mcmc.pars[,,1]: simulated means of the two components
# mcmc.pars[,,2]: simulated variances
# mcmc.pars[,,3]: simulated weights
# the computed allocation matrix is p
p<-data_list$"p"
run<-stephens(p)
# apply the permutations returned by typing:
reordered.mcmc<-permute.mcmc(mcmc.pars,run$permutations)
# reordered.mcmc[,,1]: reordered means of the components
# reordered.mcmc[,,2]: reordered variances
# reordered.mcmc[,,3]: reordered weights
data("mcmc_output", package = "bayesmix")
library("label.switching")
data("mcmc_output")
# mcmc parameters are stored to array \code{mcmc.pars}
mcmc.pars<-data_list$"mcmc.pars"
mcmc.pars[,,1]: simulated means of the two components
mcmc_output
data("mcmc_output")
data("mcmc_output")
View(data_list)
View(data_list)
install.packages("spdep")
install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/testing"), dep=TRUE)
remotes::install_github("inlabru-org/inlabru")
round(df$BI_aegypti),0)
uf_df <- data.frame(
"N"  = I(list(
c("AC", "AP", "AM", "PA", "RO", "RR", "TO")
)),
"NE" = I(list(
c("AL", "BA", "CE", "MA", "PB", "PE", "PI", "RN", "SE")
)),
"CW" = I(list(c(
"DF", "GO", "MT", "MS"
))),
"SE" = I(list(c(
"ES", "MG", "RJ", "SP"
))),
"S"  = I(list(c("PR", "RS", "SC")))
)
View(uf_df)
uf_df
uf_ls <- c()
for (i in region) {
uf_ls_temp <- unlist(uf_df[i])
uf_ls <- c(uf_ls, uf_ls_temp)
}
20*20
1/188.3
36/12
0.7*0.7
library(xaringan)
library(sf)
library(remotes)
remotes::install_github("geocompr/geocompkg",
upgrade = "ask", dependencies = TRUE, force = TRUE)
remotes::install_github("nowosad/spDataLarge")
warning()
warnings()
warnings()
remotes::install_github("nowosad/spDataLarge")
library(terra)
remotes::install_github("nowosad/spDataLarge")
library(spDataLarge)
remotes::install_github("jhelvy/renderthis", force=TRUE)
remotes::install_github('rstudio/chromote')
install.packages("webshot2")
library(renderthis)
library(webshot2)
library(xaringan)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(c("graph", "Rgraphviz"), dep=TRUE)
inla.upgrade(testing=TRUE)
library(INLA)
inla.upgrade(testing=TRUE)
remove.packages("INLA")
install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/testing"), dep=TRUE)
install.packages("INLA", repos = c(getOption("repos"), INLA = "https://inla.r-inla-download.org/R/testing"), dep = TRUE)
setwd("C:/Francisco")
packages <- c("INLA","inlabru" ,"dplyr","ggplot2","GGally","naniar", "sf")
lapply(packages, require, character.only = TRUE)
rm(packages)
library(sf)
coord <- df[c("coordx", "coordy")]
colnames(coord) <- c("x","y")
df <- read.csv("df.csv", header=TRUE)
df <- df %>%  # mutate() adds new variables and preserves existing ones
mutate(SEASON3 = case_when(
SEASON == "VERAO" ~ "SU",
SEASON == "OUTONO" ~ "AU",
SEASON == "INVERNO" ~ "WI",
SEASON == "PRIMAVERA" ~ "SP"
))
df_com$BI <- round(df_com$BI_aegypti, digits = 0)
df_com$PI <- round(df_com$PI_aegypti, digits = 0)
df$BI <- round(df$BI_aegypti, digits = 0)
df$PI <- round(df$PI_aegypti, digits = 0)
df.sf = df
########################################### S-T model with INLA
library(sf)
df.sf = st_as_sf(df, coords = c("x", "y"),
crs = "+proj=utm +zone=23 +south +units=km +ellps=aust_SA +towgs84=-67.35,3.88,-38.22",
agr = "constant")
st_crs(df.sf)
coords <- unique(df.sf[c("x", "y")])
class(df.sf)
View(df.sf)
coor <- stat_sf_coordinates(df.sf)
sp.bdry <-  as(df.sf, "Spatial") %>% inla.sp2segment()
coords = dplyr::distinct(df.sf, geom, .keep_all = TRUE)
View(df.sf)
coords <- unique(df[c("x", "y")])
(u = st_equals(df.sf, retain_unique = TRUE))
View(u)
coords = dplyr::distinct(df.sf, geom, .keep_all = TRUE)
View(df.sf)
coords = dplyr::distinct(df.sf, geometry, .keep_all = TRUE)
View(coords)
coords = dplyr::distinct(df[c("x", "y")])
View(coords)
df_com <- na.omit(df)
data.agg <- df %>%
group_by(x=x, y=y) %>%
dplyr::summarise(aegypti = sum(BI, na.rm=TRUE)) %>%
ungroup()
head(data.agg)
# Variogram (only spatial)
library(gstat)
coordinates(data.agg) = ~x+y
aegypti.vgm = variogram(aegypti~1, data.agg)
plot(aegypti.vgm)
model.1 <- fit.variogram(aegypti.vgm, vgm(c("Mat")))
model.1 #
df_com <- na.omit(df)
data.agg <- df %>%
group_by(x=x, y=y) %>%
dplyr::summarise(aegypti = sum(BI_aegypti, na.rm=TRUE)) %>%
ungroup()
head(data.agg)
# Variogram (only spatial)
library(gstat)
coordinates(data.agg) = ~x+y
aegypti.vgm = variogram(aegypti~1, data.agg)
plot(aegypti.vgm)
model.1 <- fit.variogram(aegypti.vgm, vgm(c("Mat")))
model.1
data.agg = df.sf
coordinates(data.agg) = ~x+y
data.agg = df
coordinates(data.agg) = ~x+y
aegypti.vgm = variogram(aegypti~1, data.agg)
library(gstat)
coordinates(data.agg) = ~x+y
aegypti.vgm = variogram(BI~1, data.agg)
data.agg = na.omit(df)
coordinates(data.agg) = ~x+y
aegypti.vgm = variogram(BI~1, data.agg)
plot(aegypti.vgm)
model.1 <- fit.variogram(aegypti.vgm, vgm(c("Mat")))
model.1 #
#boundary <- inla.nonconvex.hull(as.matrix(coords[,1:2]), convex = -0.05)
boundary <- inla.nonconvex.hull(as.matrix(coords[,1:2]), convex = -0.04)
sub.data = dplyr::distinct(df.sf, geometry, .keep_all = TRUE) # subset the dataset
View(sub.data)
aegypti.mesh <- inla.mesh.2d(boundary = boundary,
max.edge = c(35,60),
loc = st_transform(sub.data$geometry),
offset = -0.2, # see Elias p74
#offset = -0.5, # see Elias p74
cutoff = 2) #
aegypti.mesh <- inla.mesh.2d(boundary = boundary,
max.edge = c(35,60),
loc = st_transform(sub.data$geometry),
offset = -0.2, # see Elias p74
#offset = -0.5, # see Elias p74
CRS = st_crs(sub.data),
cutoff = 2)
st_crs(sub.data)
aegypti.mesh <- inla.mesh.2d(boundary = boundary,
max.edge = c(35,60),
loc = st_transform(sub.data$geometry),
offset = -0.2, # see Elias p74
#offset = -0.5, # see Elias p74
CRS = TRUE,
cutoff = 2) # us
?inla.mesh.2d
loc = st_transform(sub.data$geometry)
aegypti.mesh <- inla.mesh.2d(boundary = boundary,
max.edge = c(35,60),
loc = st_transform(sub.data$geometry),
offset = -0.2, # see Elias p74
#offset = -0.5, # see Elias p74
CRS = "+proj=utm +zone=23 +south +units=km +ellps=aust_SA +towgs84=-67.35,3.88,-38.22",
cutoff = 2) # used to
aegypti.mesh <- inla.mesh.2d(boundary = boundary,
max.edge = c(35,60),
loc = st_transform(sub.data$geometry),
offset = -0.2, # see Elias p74
#offset = -0.5, # see Elias p74
CRS = st_crs(df.sf),
cutoff = 2) #
aegypti.mesh <- inla.mesh.2d(boundary = boundary,
max.edge = c(35,60),
#loc = st_transform(sub.data$geometry),
offset = -0.2, # see Elias p74
#offset = -0.5, # see Elias p74
CRS = df.sf,
cutoff = 2) # used
st_crs(df.sf)$proj4string
Edf.sp <- as(df.sf, "Spatial")
rm(Edf.sp)
df.sp <- as(df.sf, "Spatial")
sp.bdry <- df.sp %>% inla.sp2segment()
aegypti.mesh <- inla.mesh.2d(boundary = boundary,
max.edge = c(35,60),
#loc = st_transform(sub.data$geometry),
offset = -0.2, # see Elias p74
#offset = -0.5, # see Elias p74
CRS = df.sf,
cutoff = 2) # us
aegypti.mesh <- inla.mesh.2d(boundary = boundary,
max.edge = c(35,60),
#loc = st_transform(sub.data$geometry),
offset = -0.2, # see Elias p74
#offset = -0.5, # see Elias p74
#CRS = df.sf,
cutoff = 2) # used to avoid building many small triangles around clustered locations
dim(coords)
p5 <- coords[,1:2]
0.15*max(diff(range(p5[,1])), diff(range(p5[,2]))) #
str(args(inla.nonconvex.hull))
coords = dplyr::distinct(sub.data[c("x", "y")])
coords = dplyr::distinct(df.sf[,32], geometry, .keep_all = TRUE) # subset the dataset
coords
coords = dplyr::distinct(df[c("x", "y")])
coords2 = dplyr::distinct(df.sf[,32], geometry, .keep_all = TRUE) # subset the dataset
#boundary <- inla.nonconvex.hull(as.matrix(coords[,1:2]), concave=130)
boundary <- inla.nonconvex.hull(as.matrix(coords2[,1:2]))
#boundary <- inla.nonconvex.hull(as.matrix(coords[,1:2]), concave=130)
boundary <- inla.nonconvex.hull(coords2[,1:2]
)
coords.sp =as(coords2, "Spatial")
#boundary <- inla.nonconvex.hull(as.matrix(coords[,1:2]), concave=130)
boundary <- inla.nonconvex.hull(coords.sp[,1:2]
)
?
)
?inla.nonconvex.hull
coords = dplyr::distinct(df[c("x", "y")])
boundary <- inla.nonconvex.hull(as.matrix(coords[,1:2]), CRS=st_crs(df.sf))
aegypti.mesh = inla.mesh.2d(loc = coords, max.edge = c(35, 60))
ggplot() + gg(aegypti.mesh2) + coord_equal()
aegypti.mesh2 = inla.mesh.2d(loc = coords, max.edge = c(35, 60))
ggplot() + gg(aegypti.mesh2) + coord_equal()
ggplot() +
gg(aegypti.mesh2) +
geom_point(data = df, aes(x, y))
aegypti.mesh <- inla.mesh.2d(boundary = boundary,
max.edge = c(35,60))
boundary <- inla.nonconvex.hull(as.matrix(coords[,1:2]))
aegypti.mesh <- inla.mesh.2d(boundary = boundary,
max.edge = c(35,60))
#boundary <- inla.nonconvex.hull(as.matrix(coords[,1:2]), convex = -0.05)
boundary <- inla.nonconvex.hull(as.matrix(coords[,1:2]), convex = -0.04)
aegypti.mesh2 = inla.mesh.2d(loc = coords, max.edge = c(35, 60))
aegypti.mesh <- inla.mesh.2d(boundary = boundary,
max.edge = c(35,60))
ggplot() +
gg(aegypti.mesh) +
geom_point(data = df, aes(x, y))
boundary <- inla.nonconvex.hull(as.matrix(coords[,1:2]))
ggplot() +
gg(aegypti.mesh) +
geom_point(data = df, aes(x, y))
ggplot() +
gg(aegypti.mesh) +
geom_point(data = sub.data, aes(x, y))
ggplot() +
gg(aegypti.mesh) +
geom_point(data = df, aes(x, y))
out <- inla.mesh.assessment(aegypti.mesh,
spatial.range = 45, # spatial range from the variogram
alpha = 2)
print(names(out))
range(out$sd.dev[!is.na(out$sd.dev)])
ggplot() + gg(out, aes(color = sd.dev)) + coord_equal() +
scale_color_gradient(limits = range(out$sd.dev, na.rm = TRUE))
## The number of vertices in the mesh
aegypti.mesh$n
aegypti.mesh <- inla.mesh.2d(boundary = boundary,
max.edge = c(25,60))
## The number of vertices in the mesh
aegypti.mesh$n
ggplot() +
gg(aegypti.mesh) +
geom_point(data = df, aes(x, y))
aegypti.mesh <- inla.mesh.2d(boundary = boundary,
max.edge = c(30,60))
## The number of vertices in the mesh
aegypti.mesh$n
ggplot() +
gg(aegypti.mesh) +
geom_point(data = df, aes(x, y))
aegypti.mesh <- inla.mesh.2d(boundary = boundary,
max.edge = c(35,60))
ggplot() +
gg(aegypti.mesh) +
geom_point(data = df, aes(x, y))
#boundary <- inla.nonconvex.hull(as.matrix(coords[,1:2]), convex = -0.05)
boundary <- inla.nonconvex.hull(as.matrix(coords[,1:2]), convex = -0.05)
aegypti.mesh <- inla.mesh.2d(boundary = boundary,
max.edge = c(35,60))
ggplot() +
gg(aegypti.mesh) +
geom_point(data = df, aes(x, y))
aegypti.mesh <- inla.mesh.2d(boundary = boundary,
max.edge = c(30,70))
ggplot() +
gg(aegypti.mesh) +
geom_point(data = df, aes(x, y))
## The number of vertices in the mesh
aegypti.mesh$n
aegypti.mesh <- inla.mesh.2d(boundary = boundary,
max.edge = c(30,70), #max.edge = c(35,60),
#loc = st_transform(sub.data$geometry),
offset = -0.2, # see Elias p74
#offset = -0.5, # see Elias p74
#CRS = df.sf,
cutoff = 5) #
ggplot() +
gg(aegypti.mesh) +
geom_point(data = df, aes(x, y))
plot(aegypti.mesh, asp = 1, main = "")
points(coords[, 1], coords[, 2], pch = 19, cex = 0.5, col = "red")
plot(aegypti.mesh, asp = 1, main = "")
lines(boundary, col = 3)
points(coords[, 1], coords[, 2], pch = 19, cex = 0.5, col = "red")
out <- inla.mesh.assessment(aegypti.mesh,
spatial.range = 45, # spatial range from the variogram
alpha = 2)
out <- inla.mesh.assessment(aegypti.mesh,
spatial.range = 45, # spatial range from the variogram
alpha = 3/2)
print(names(out))
range(out$sd.dev[!is.na(out$sd.dev)])
out <- inla.mesh.assessment(aegypti.mesh,
spatial.range = 40, # spatial range from the variogram
alpha = 3/2)
print(names(out))
range(out$sd.dev[!is.na(out$sd.dev)])
setwd("C:/Users/Monica/Dropbox/TEACHING/YEAR_2023/Bayes_Spatial_2023/Material/Practical3b")
