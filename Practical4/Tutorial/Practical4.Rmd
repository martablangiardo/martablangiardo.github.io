---
title: "Practical 4 - A space-time model with `inlabru`"
author: "Spatial and Spatio-Temporal Bayesian Models with `R-INLA`"
header-includes:
    - \usepackage{bm}
output:
  html_document:
    toc: true
    toc_float: true
bibliography: biblio.bib
---
  
\pagenumbering{gobble} 
\pagenumbering{arabic} 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE, fig.align = "center")
```

## 1. Introduction
In this tutorial we use a dataset that comprises daily maximum
8-hour average ground level ozone (O3, ppb) concentrations for the period July 1 and August 31 in 2006, measured at 28 monitoring sites in the state of New York, USA. 
The stations are part of the Environmental Protection Agency (EPA) monitoring network.
Ozone  occurs naturally in the upper atmosphere and protects the Earth from the sun's rays. However, at ground level it can be harmful for population health, as it can lead to adverse respiratory effects. Ozone is most likely to reach worrisome levels on hot sunny days in urban environments (even so it can still reach high levels during colder months).  
Ozone is one of the “criteria pollutants” regularly monitored by the US EPA.

The dataset used for this tutorial is included in the packages `spBayes` and `spTimer`.
Today we will use the package `spTimer` by @Bakar2015 to model ozone concentrations in New York state. The paper by @Bakar2015 uses this dataset for demonstration. Here we follow their analysis.


The data available are as follows:

* `s.index`: index of the monitoring station in the NY state

* `Longitude` and `Latitude`: spatial coordinates of the monitoring stations

* `Year`, `Month` and `Day`: temporal coordinates of the measurement

* `o8hrmax`: daily 8-hour maximum average ozone concentrations (parts per billion) 

* `cMAXTMP`: maximum temperature (in degree Celsius) 

* `WDSP`: wind speed (knots), 

* `RH`: percentage average relative humidity 

Of the 1,736 possible observations, i.e., n=28 locations times T=62 daily `o8hrmax` measurements, 114 are missing. 


We use `o8hrmax` concentrations as outcome and `cMAXTMP`, `WDSP`, and `RH` as predictors.


## 2. The New York dataset: explore the data

The data are obtained from 28 monitoring sites, between July 1 and August 31 in 2006. 

* Load the data in `R` 

```{r eval=TRUE, echo=TRUE, message=FALSE}
library(tidyverse)
library(spTimer)
data(NYdata)
dim(NYdata)
```


* Now, we print the data, formatting these in a table.

```{r eval=TRUE, echo=TRUE, message=FALSE}
head(NYdata)
```


* We provide a map of the monitoring station using `mapview` package.  Here we plot the longitude and latitude using the World Geographic System 1984 (WGS84) projection, which is referenced as European Petroleum Survey Group (EPSG) 4326 (note that, EPSG 4326 is the projection used by web maps such as Google Maps)

```{r eval=TRUE, echo=TRUE, message=FALSE, fig.cap = "Map of the monitoring stations in New York State"}
library(mapview) 
stations <- cbind(unique(NYdata[,1]), unique(NYdata[,2:3]))

# set the map projection to a common projection standard such as WGS84 via the argument crs = 4326
mapview(stations, xcol = "Longitude", ycol = "Latitude", crs = 4269, grid = FALSE)
```

* We create a variable `date` using the package `lubridate`, which is part of the core `tidyverse`.

```{r eval=TRUE, echo=TRUE, message=FALSE}
library(lubridate)
NYdata <- NYdata %>%
  mutate(date = make_date(Year, Month, Day))
glimpse(NYdata)
```


* We now plot the concentrations of ozone for each monitoring station using the package `mvtsplot`, which allows the visualization of Multivariate time Series (Link: http://www.biostat.jhsph.edu/~rpeng/RR/mvtsplot/). To be able to use it, we need to convert the data from long to wide format.

```{r eval=TRUE, echo=TRUE, message=FALSE}
# select ozone data
O3 <- NYdata %>% select(s.index, o8hrmax, date)
dim(O3) #1736    3

O3_wide = O3 %>% spread(s.index, o8hrmax)
dim(O3_wide) #62 29

O3_wide <- O3_wide[,-1] # remove date
O3_wide <- data.matrix(O3_wide)
dim(O3_wide)

colnames(O3_wide) <- unique(O3[,1])

```

And now plot the ozone concentrations for the 28 monitoring stations

```{r eval=TRUE, echo=TRUE, fig.cap = "Daily ozone levels for 28 monitoring stations, Jul 1– Aug 31, 2006"}
library(mvtsplot)
# Daily ozone levels for 28 monitoring stations, Jul 1– Aug 31, 2006.
mvtsplot(O3_wide, group = NULL, xtime = NULL, norm = c("global"),
         levels = 3, smooth.df = NULL, margin = TRUE, sort =NULL,
         main = "", palette = "PRGn", rowstat = "median", xlim,
         bottom.ylim = NULL, right.xlim=NULL, gcol = 3)

```
In the plot we use as color `PRGn` (default) from the `RColorBrewer` palettes. Here green indicates high values and purple indicates low values. Missing data are denoted by the color white. The bottom panel shows the overall median.  Finally, on the right hand side panel, we can see the boxplots of the data in each time series.


* Moreover, we can check the basic statistics for ozone concentrations and make the histogram 

```{r eval=TRUE, echo=TRUE, message=FALSE, fig.cap = "Histgram of ozone concentrations"}
summary(NYdata$o8hrmax)
NYdata %>% 
  ggplot()+
  geom_histogram(aes(o8hrmax), col="orange")
```


* We can visualize the relationships between the data using `GGally`: 

```{r eval=TRUE, echo=TRUE, message=FALSE, fig.cap = "Figure 4. Plot of the correlation between variables in analysis", fig.height=6, fig.width = 11}
library(GGally)
ggpairs(NYdata[,7:10]) # print correlations between variables
```

* We print the table of the correlations between ozone and the three predictors using the package `corrr`:

```{r eval=TRUE, echo=TRUE, message=FALSE}
library(corrr)
tab_cor = NYdata %>%
  select(o8hrmax, cMAXTMP, WDSP, RH) %>%
  correlate() %>%
  shave(upper = TRUE) %>%
  fashion(decimals = 2, na_print = "—") 

tab_cor
```


* We create a variable which is an index for time:
```{r}
NYdata$time = rep(1:n_distinct(NYdata$date),
                   n_distinct(NYdata$s.index))
```
and we consider, for reducing the computational costs, only the first 30 time points:
```{r}
NYdata = NYdata %>% 
  filter(time <= 30)
```

Compute the square root transformation of the response variable
```{r}
NYdata$sqrto8hrmax = sqrt(NYdata$o8hrmax)
```


```{r}
# define prediction sites for cross-validation (i.e. validation sites)
s <- c(8,11,12,14,18,21,24,28) # 8 stations

# Training data
DataFit = NYdata %>% 
  filter(!(s.index %in% s))
dim(DataFit)
# Dim = 600 (20stations*30days) * 12

# Validation data
# select data for prediction (validation set)
DataValPred =  NYdata %>% 
  filter(s.index %in% s)
dim(DataValPred)
# dim = 240 (8stations*30days) * 12
```

## 3. Geostatistical spatio-temporal model

We now implement the spatio-temporal linear regression model for ozone concentrations using `spTimer`. Let: 

* $\boldsymbol{Y}_t =(Y(\mathbf{s}_1,t), \dots, Y(\mathbf{s}_n,t))'$ be the observed data at location $\mathbf{s}$ in day $t$

* $\boldsymbol{O}_t =(O(\mathbf{s}_1,t), \dots, O(\mathbf{s}_n,t))'$ be the true value corresponding to $\boldsymbol{Y}_t$.

We use a hierarchical structure and we fit the following Bayesian model, with nugget effect model together with an independent Gaussian Process (GP) model at each time point:

\begin{equation*}
\begin{split}
 %Y(\mathbf{s}_i,t) &= \boldsymbol{X}'(\mathbf{s}_i,t) \boldsymbol{\beta} + \boldsymbol{\eta}(\mathbf{s}_i,t)+\boldsymbol{\epsilon}(\mathbf{s}_i,t)
 \boldsymbol{Y}_t &= \boldsymbol{O}_t +\boldsymbol{\epsilon}_t\\
  \boldsymbol{O}_t &= \boldsymbol{X}_t \boldsymbol{\beta} + \boldsymbol{\eta}_t
\end{split}
\end{equation*}

where:

+ $\boldsymbol{X}_t$ are the covariate values and $\boldsymbol{\beta}$ are the regression coefficients

+ $\boldsymbol{\eta}_t=(\eta(\mathbf{s}_1,t), \dots, \eta(\mathbf{s}_n,t))'$ are the spatio-temporal random effects, assumed to follow $N(\mathbf{0}, \Sigma_{\eta})$  independently in time, where $\Sigma_{\eta}=\sigma_{\eta}^{2} S_{\eta}$, here $\sigma_{\eta}^2$ is the site invariant spatial variance  and $S_{\eta}$ is the spatial correlation matrix.

+ $\boldsymbol{\epsilon}_t=(\epsilon(\mathbf{s}_1,t), \dots, \epsilon(\mathbf{s}_n,t))'$ is the nugget effect or the pure error term, independent in space and time.

## 4. Create the mesh and the SPDE model
* We consider a rough mesh:
```{r}
library(INLA)
bnd <- inla.nonconvex.hull(cbind(DataFit$Longitude, DataFit$Latitude),
                            convex = 1)

mesh = inla.mesh.2d(loc = cbind(DataFit$Longitude, DataFit$Latitude),
                    #max.edge = c(0.5, 4))
                    max.n.strict = c(100, 20))
```

Explain the option `max.n`.
```{r, eval=F}
library(inlabru)
ggplot() +
  gg(mesh) +
  geom_point(data = DataFit, aes(Longitude, Latitude)) 
```


Given the mesh it is now possible to create the SPDE model using the `inla.spde2.matern` function:

```{r}
spde = inla.spde2.pcmatern(mesh = mesh,
                           prior.range = c(0.1, 0.9),
                           prior.sigma = c(1, 0.01)) 
spde$n.spde #n. of mesh vertices
```

** 5. Prepare everything for `inlabru`
We first transform the `df` data frame into a **spatial object** (`SpatialPointsDataFrame`)
```{r}
coordinates(DataFit) = c("Longitude","Latitude")
class(DataFit)
```

```{r}
cmp  = ~ Intercept(1) +   cMAXTMP + WDSP + RH +
  SPDE(coordinates, model = spde,
       group = time, control.group = list(model = "ar1")) 
```

We then define the **likelihood**
```{r}
library(inlabru)
lik = like(formula = sqrto8hrmax ~ Intercept  + cMAXTMP + WDSP + RH + SPDE,
           family = "gaussian",
           data = DataFit)
```

```{r,eval=T}
#p(sigma > sigma0)=alpha
pc.prec = list(prec = list(prior = "pc.prec", param = c(70, 0.01)))

fit = bru(cmp, lik,
          options =  list(control.family = list(hyper = pc.prec)))
summary(fit)
```

```{r}
names(fit$marginals.fixed)
names(fit$marginals.random)
fit$summary.fixed[,c("mean","0.025quant","0.975quant")]
```

```{r}
int.plot <- plot(fit, "Intercept")
spde.range <- spde.posterior(fit, "SPDE", what = "range")
spde.logvar <- spde.posterior(fit, "SPDE", what = "log.variance")
range.plot <- plot(spde.range)
var.plot <- plot(spde.logvar)

multiplot(range.plot, var.plot, int.plot)

plot(spde.posterior(fit, "SPDE", what = "matern.correlation"))
```

## 5. Prediction at the hold-out sites
```{r}
coordinates(DataValPred) = c("Longitude","Latitude")
class(DataValPred)
```


```{r}
ValPred = predict(fit, DataValPred,
                ~ Intercept + SPDE + cMAXTMP + WDSP + RH)
```

```{r}
as.data.frame(ValPred) %>%
  ggplot() + 
  geom_line(aes(time, sqrto8hrmax, group = s.index), color = "red") +
  geom_line(aes(time, median, group = s.index)) +
  geom_ribbon(aes(time, ymin = q0.025, ymax = q0.975, group = s.index), alpha = 0.5) +
  facet_wrap(.~s.index)
```

## 6. Prediction at the grid level

We now perform prediction on a grid to obtain a continuous surface of ozone concentrations. To do so, we read in `NYgrid`, which contains a total of 6200 rows for 62 days of observations for 10x10 = 100 grid points. Then we re-run the GP model for all the points in the dataset (i.e. NYdata) and make prediction on the grid.

```{r}
data(NYgrid)
dim(NYgrid)
class(NYgrid)
head(NYgrid)
```

```{r}
NYgrid %>% 
  distinct(Longitude,Latitude) %>% 
  ggplot()+
  geom_point(aes(Longitude,Latitude)) +
  gg(mesh)
```


* We create a variable which is an index for time:
```{r}
NYgrid <- NYgrid %>%
  mutate(date = make_date(Year, Month, Day))
glimpse(NYgrid)

NYgrid$time = rep(1:n_distinct(NYgrid$date),
                   n_distinct(NYgrid$s.index))
```

```{r}
NYgrid = NYgrid %>% filter(time <= 6)
```


```{r}
coordinates(NYgrid) = c("Longitude","Latitude")
class(NYgrid)
```

- Transform the grid into a `SpatialPixelsDataFrame`:
```{r}
grid = sp::SpatialPixelsDataFrame(NYgrid@coords,
                                  data = NYgrid@data)
class(grid)
dim(grid@data)
glimpse(grid@data)
```

- Prova MASKING
```{R}
library(maps)
eus <- (map.where(database="state", x=NYgrid@coords[,1], y=NYgrid@coords[,2]))
dummy <- rep(0, length(NYgrid@coords[,1]))
eastUS <- NULL
eastUS <- data.frame(lon=NYgrid@coords[,1],lat=NYgrid@coords[,2],state=eus,dummy=dummy)
eastUS[!is.na(eastUS[,3]),4]<-1
eastUS[eastUS[,3]=="pennsylvania" & !is.na(eastUS[,3]),4]<-0
eastUS[eastUS[,3]=="new jersey" & !is.na(eastUS[,3]),4]<-0
eastUS[eastUS[,3]=="connecticut" & !is.na(eastUS[,3]),4]<-0
eastUS[eastUS[,3]=="massachusetts:main" & !is.na(eastUS[,3]),4]<-0
eastUS[eastUS[,3]=="new hampshire" & !is.na(eastUS[,3]),4]<-0
eastUS[eastUS[,3]=="vermont" & !is.na(eastUS[,3]),4]<-0
maskindex <- eastUS[, 4]
prova <- grid[!!maskindex,]

ggplot()+
  gg(prova, aes(fill=RH))+
  facet_wrap(~time)
```

- COMPUTE PREDICTIONS
```{r}
GridPred = predict(fit, grid,
                ~ (Intercept + SPDE + cMAXTMP + WDSP + RH)^2)
head(GridPred)

```

 AND MAPS   
```{r}
library(viridis)
ggplot() + 
  gg(GridPred, aes(Longitude, Latitude, fill = mean))  +
  facet_wrap(.~time) + 
  scale_fill_viridis() +
  coord_equal()+
  geom_point(data = stations, aes(Longitude, Latitude))

```

