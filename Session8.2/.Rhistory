z <- mcmc$results[-(1:burn), 1:n]
mcmc$results
mcmc.pars[ , , 1] <- mcmc$results[-(1:burn), (n+K+1):(n+2*K)]
View(z)
p <- array(data = NA, dim = c(m, n, K))
for (iter in 1:m){
for(i in 1:n){
kdist <- mcmc.pars[iter, , 3]*dnorm(x[i], mcmc.pars[iter, , 1],
+ sqrt(mcmc.pars[iter, , 2]))
skdist <- sum(kdist)
for(j in 1:K){
p[iter, i, j] = kdist[j]/skdist}}}
p
dim(p)
#load a toy example: MCMC output consists of the random beta model
# applied to a normal mixture of \code{K=2} components. The number
# of observations is equal to \code{n=5}. The number of MCMC samples
# is equal to \code{m=300}. The matrix of allocation probabilities
# is stored to matrix \code{p}.
data("mcmc_output")
data("mcmc_output", package = "bayesmix)
# mcmc parameters are stored to array \code{mcmc.pars}
mcmc.pars<-data_list$"mcmc.pars"
# mcmc.pars[,,1]: simulated means of the two components
# mcmc.pars[,,2]: simulated variances
# mcmc.pars[,,3]: simulated weights
# the computed allocation matrix is p
p<-data_list$"p"
run<-stephens(p)
# apply the permutations returned by typing:
reordered.mcmc<-permute.mcmc(mcmc.pars,run$permutations)
# reordered.mcmc[,,1]: reordered means of the components
# reordered.mcmc[,,2]: reordered variances
# reordered.mcmc[,,3]: reordered weights
data("mcmc_output", package = "bayesmix")
library("label.switching")
data("mcmc_output")
# mcmc parameters are stored to array \code{mcmc.pars}
mcmc.pars<-data_list$"mcmc.pars"
mcmc.pars[,,1]: simulated means of the two components
mcmc_output
data("mcmc_output")
data("mcmc_output")
View(data_list)
View(data_list)
install.packages("spdep")
install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/testing"), dep=TRUE)
remotes::install_github("inlabru-org/inlabru")
round(df$BI_aegypti),0)
uf_df <- data.frame(
"N"  = I(list(
c("AC", "AP", "AM", "PA", "RO", "RR", "TO")
)),
"NE" = I(list(
c("AL", "BA", "CE", "MA", "PB", "PE", "PI", "RN", "SE")
)),
"CW" = I(list(c(
"DF", "GO", "MT", "MS"
))),
"SE" = I(list(c(
"ES", "MG", "RJ", "SP"
))),
"S"  = I(list(c("PR", "RS", "SC")))
)
View(uf_df)
uf_df
uf_ls <- c()
for (i in region) {
uf_ls_temp <- unlist(uf_df[i])
uf_ls <- c(uf_ls, uf_ls_temp)
}
20*20
1/188.3
36/12
0.7*0.7
library(xaringan)
library(sf)
library(remotes)
remotes::install_github("geocompr/geocompkg",
upgrade = "ask", dependencies = TRUE, force = TRUE)
remotes::install_github("nowosad/spDataLarge")
warning()
warnings()
warnings()
remotes::install_github("nowosad/spDataLarge")
library(terra)
remotes::install_github("nowosad/spDataLarge")
library(spDataLarge)
remotes::install_github("jhelvy/renderthis", force=TRUE)
remotes::install_github('rstudio/chromote')
install.packages("webshot2")
library(renderthis)
library(webshot2)
library(xaringan)
# rmarkdown
install.packages("rmarkdown", dep = TRUE)
# xaringan
remotes::install_github('yihui/xaringan')
# xaringan
remotes::install_github('yihui/xaringan')
install.packages("cli")
install.packages("cli")
install.packages("cli")
install.packages("cli")
install.packages("cli")
library()
install.packages("cli")
library(devtools)
install.packages("cli")
install.packages("cli")
install.packages("cli")
remove.packages(xaringan)
remove.packages("rmarkdown")
remove.packages("xaringan")
remotes::install_github("mitchelloharawild/icons")
install.packages("tikzDevice")
install.packages("kableExtra")
install.packages("dplyr")
install.packages("shiny")
install.packages("RefManageR")
library()
remotes::install_github("gadenbuie/xaringanExtra")
install.packages("servr")
install.packages("kableExtra")
library(xaringan)
library(xaringanExtra)
.libPaths()
1500*3
150*4
600*3
4500+1800
4*130
520*3
6300+2500
10-8800
10000-8800
1500*2
150*4*2
3000+1200
52.4/10.1
52.4^2/10.1
5.18*5.18
26.8*10.1
(52.4*52.4)/10.1
52.4/1000
271.85/1000
knitr::opts_chunk$set(echo = TRUE)
library(gstat)
# We use Meuse dataset, which includes concentrations of zinc
# measured at 155 sampling sites within the Meuse River plain
data(meuse)
library(sp)
library(gstat)
# We use Meuse dataset, which includes concentrations of zinc
# measured at 155 sampling sites within the Meuse River plain
data(meuse)
# Transform the dataframe into a SpatialPointDataFrame
coordinates(meuse) = ~x+y # the function coordinates
# promotes the data.frame meuse
# into a SpatialPointsDataFrame
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
# Construct the variogram
meuse.vgm = variogram(log(zinc)~1, meuse) # we assume a constant trend for
# the variable log(zinc)
# Plot the experimental variogram
plot(meuse.vgm)
plot(meuse.vgm, plot.numbers = TRUE, pch = "+") # The numbers of points in the
# lag group used to compute the corresponding value of gamma(h)
# Fit a variogram model
model.1 = fit.variogram(meuse.vgm, vgm("Sph"))
plot(meuse.vgm, model=model.1)
# Look at the result of the fit
model.1
# We can also specify a set of models. In this case the best fitting is returned
model.2 = fit.variogram(meuse.vgm, vgm(c("Exp", "Sph")))
model.2 # here the spherical model with nugget=0.051, partial sill =0.591 and range=897 is chosen
# Specify theoretical variogram with its characteristics
model.final = fit.variogram(meuse.vgm, vgm(psill=0.59,"Sph",range=897,nugget=0.05))
plot(meuse.vgm, model=model.final)
# We use Meuse dataset, which includes concentrations of zinc
# measured at 155 sampling sites within the Meuse River plain
data(meuse)
View(meuse)
# Transform the dataframe into a SpatialPointDataFrame
coordinates(meuse) = ~x+y # the function coordinates
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
hist(meuse$zinc) # we see a strong right skew in the data, so we log-transform them
hist(meuse$zinc) # we see a strong right skew in the data, so we log-transform them
# Lagged scatter plot
hscat(log(zinc)~1, meuse,(0:9)*100) # the correlation is quite strong when the lag
# We use Meuse dataset, which includes concentrations of zinc
# measured at 155 sampling sites within the Meuse River plain
data(meuse)
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
# Transform the dataframe into a SpatialPointDataFrame
coordinates(meuse) = ~x+y # the function coordinates
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
hist(meuse$zinc) # we see a strong right skew in the data, so we log-transform them
# Lagged scatter plot
hscat(log(zinc)~1, meuse,(0:9)*100) # the correlation is quite strong when the lag
# Construct the variogram
meuse.vgm = variogram(log(zinc)~1, meuse) # we assume a constant trend for
# Plot the experimental variogram
plot(meuse.vgm)
plot(meuse.vgm, plot.numbers = TRUE, pch = "+") # The numbers of points in the
lot(meuse.vgm, plot.numbers = TRUE, pch = "+") #
plot(meuse.vgm, plot.numbers = TRUE, pch = "+") #
# Construct the variogram
meuse.vgm = variogram(log(zinc)~1, meuse) # we assume a constant trend for
plot(meuse.vgm, plot.numbers = TRUE, pch = "+") # The numbers of points in the
# Fit a variogram model
model.1 = fit.variogram(meuse.vgm, vgm("Sph"))
plot(meuse.vgm, model=model.1)
# Look at the result of the fit
model.1
model.final = fit.variogram(meuse.vgm, vgm(psill=0.59,"Sph",range=897,nugget=0.05))
plot(meuse.vgm, model=model.final)
View(meuse)
head(meuse)
# We use Meuse dataset, which includes concentrations of zinc
# measured at 155 sampling sites within the Meuse River plain
data(meuse)
head(meuse)
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
# Transform the dataframe into a SpatialPointDataFrame
# the function coordinates promotes the data.frame meuse into a SpatialPointsDataFrame
coordinates(meuse) = ~x+y
bubble(meuse, "zinc", col=c("#00ff0088", "#00ff0088"),
main = "zinc concentrations (ppm)")
hist(meuse$zinc) # we see a strong right skew in the data, so we log-transform them
# Lagged scatter plot
hscat(log(zinc)~1, meuse,(0:9)*100) # the correlation is quite strong when the lag
# Construct the variogram
meuse.vgm = variogram(log(zinc)~1, meuse) # we assume a constant trend for
# Plot the experimental variogram
plot(meuse.vgm)
plot(meuse.vgm, plot.numbers = TRUE, pch = "+") # The numbers of points in the
# Fit a variogram model
model.1 = fit.variogram(meuse.vgm, vgm("Sph"))
plot(meuse.vgm, model=model.1)
# We can also specify a set of models. In this case the best fitting is returned
model.2 = fit.variogram(meuse.vgm, vgm(c("Exp", "Sph")))
model.2 # here the spherical model with nugget=0.051, partial sill =0.591 and range=897 is chosen
model.final = fit.variogram(meuse.vgm, vgm(psill=0.59,"Sph",range=897,nugget=0.05))
plot(meuse.vgm, model=model.final)
library("spatstat")
library("sp")
library("maptools")
data(bei)
# Create SpatialPoints object
bei.pts <- as(bei, "SpatialPoints")
#Create grid
bei.poly <- as(as.im(bei$window, dimyx=c(5, 10)), "SpatialGridDataFrame")
bei.poly <- as(bei.poly, "SpatialPolygons")
idx <- over(bei.pts, bei.poly)
tab.idx <- table(idx)
#Add number of trees
d <- data.frame(Ntrees = rep(0, length(bei.poly)))
row.names(d) <- paste0("g", 1:length(bei.poly))
d$Ntrees[as.integer(names(tab.idx))] <- tab.idx
bei.trees <- SpatialPolygonsDataFrame(bei.poly, d)
#Mapping
idx.mapping <- as.vector(t(matrix(1:50, nrow = 10, ncol = 5)))
bei.trees2 <- bei.trees[idx.mapping, ]
devtools::install_github('Keefe-Murphy/IMIFA')
library(IMIFA)
data("olive")
force(olive)
simmary(olive)
summary(olive)
data(USPSdigits)
summary(USPSdigits)
?USPSdigits
simMFA   <- mcmc_IMIFA(olive, method="MFA", n.iters=10000, range.G=3:6, range.Q=0:3, centering=FALSE,
scaling="unit", uni.type="isotropic", score.switch=FALSE)
simMFA  = mcmc_IMIFA(olive, method="MFA", n.iters=10000, range.G=3:6,
range.Q=0:3, centering=FALSE,
scaling="unit", uni.type="isotropic",
score.switch=FALSE)
simMFA  = mcmc_IMIFA(olive, method="MFA", n.iters=10000, range.G=0,
range.Q=0:3, centering=FALSE,
scaling="unit", uni.type="isotropic",
score.switch=FALSE)
simMFA  = mcmc_IMIFA(olive, method="MFA", n.iters=10000, range.G=0:2,
range.Q=0:3, centering=FALSE,
scaling="unit", uni.type="isotropic",
score.switch=FALSE)
simMFA  = mcmc_IMIFA(olive, method="MFA", n.iters=10000, range.G=3:6,
range.Q=0:3, centering=FALSE,
scaling="unit", uni.type="isotropic",
score.switch=FALSE)
simMIFA  <- mcmc_IMIFA(olive, method="MIFA", n.iters=10000, centering=TRUE,
range.G=1:3, z.init="kmeans")
54000/12
54000/12
55000/12
load("~/Downloads/ocean (1).Rdata")
View(train)
View(hold_out)
View(train)
library(INLA)
n=203
n.seas=12
trend=1:n
seasonal.sim=rep(1:n.seas, ceiling(n/n.seas))[1:n]
seasonal.sim
install.packages("spdep")
inla.doc("ar1")
library(INLA)
inla.doc("ar1")
install.packages('rmarkdown')
remotes::install_github('yihui/xaringan')
46734/12
15000/500
413565+78060.80+17303.20
46028+309529+44559.28
(400116*100)/909045.70
#library(maps)
library(INLA)
install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/testing"), dep=TRUE)
install.packages("Rgraphviz")
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("Rgraphviz")
install.packages("dplyr")
install.packages("graph")
BiocManager::install("graph")
# Remove Package
remove.packages("INLA")
install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
library(INLA)
install.packages("geostatsp")
library(INLA)
sessionInfo()
library(leaflet)
popup = c("Monica", "Marta", "Georges", "Abi", "Connor")
leaflet() |>
addProviderTiles("NASAGIBS.ViirsEarthAtNight2012") |>
addMarkers(lng = c(41, -3, 2),
lat = c(12, 52, 30),
popup = popup)
popup = c("Monica", "Marta", "Georges", "Abi", "Connor")
leaflet() |>
addProviderTiles("NASAGIBS.ViirsEarthAtNight2012") |>
addMarkers(lng = c(42, -3, 2),
lat = c(12, 52, 30),
popup = popup)
popup = "Imperial College London"
leaflet() |>
setView(51.488064, -0.172471, zoom=4) |>
addProviderTiles("NASAGIBS.ViirsEarthAtNight2012
addMarkers(lng = 51.488064,
lat = -0.172471,
popup = popup)
0
?
popup = "Imperial College London"
leaflet() |>
setView(51.488064, -0.172471, zoom=4) |>
addProviderTiles("NASAGIBS.ViirsEarthAtNight2012") |>
addMarkers(lng = 51.488064,
lat = -0.172471,
popup = popup)
library(leaflet)
popup = "Imperial College London"
leaflet() |>
setView(51.488064, -0.172471, zoom=4) |>
addProviderTiles("NASAGIBS.ViirsEarthAtNight2012") |>
addMarkers(lng = 51.488064,
lat = -0.172471,
popup = popup)
popup = "Imperial College London"
leaflet() |>
setView(51.488064, -0.172471, zoom=4) |>
addProviderTiles("NASAGIBS.ViirsEarthAtNight2012") |>
addMarkers(lng = -0.172471,
lat = 51.488064,
popup = popup)
popup = "Imperial College London"
leaflet() |>
setView(-0.172471, 51.488064, zoom=4) |>
addProviderTiles("NASAGIBS.ViirsEarthAtNight2012") |>
addMarkers(lng = -0.172471,
lat = 51.488064,
popup = popup)
set.seed(1234) #set the seed
n = 100
sigma = 0.1
beta.0 =  2
beta.1 = 0.5
x = runif(n)
eta = beta.0 +  beta.1*x
y = rnorm(n,eta,sigma)
#plot(x,y) #plot the data
my.data = data.frame(y=y,x=x)
library(INLA)
inla.list.models()
inla.list.models()$latent
names(inla.list.models()$latent)
names(inla.models()$latent)
25-100
(75*75)
1350*4
5625-5400
sqrt(225)
35*4
sqrt(144)
2021-2000
n=1043
I = matrix(NA, nrow = 2 * n, ncol = 2)
View(I)
I[1:n, 1] = 1
View(I)
I[n + 1:n, 2] = 1
View(I)
Library(mice)
library(mice)
library(INLA)
inla.doc("iid2d")
# We modify the variables age and sex as they will be passed to the model as
# weights of the latent random effects iid2d specification.
# To match the dimension of the response, they need to be twice long
age.joint = rep(fdgs.sub$age, 2)
load(fdgs)
fdgs = data(fdgs)
fdgs = data(fdgs)
# a. Subsect 1, observations with NA's
subset1 = which(is.na(fdgs$wgt) | is.na(fdgs$hgt))
library(mice)
library(INLA)
# Take a sample of the data, including missing values
fdgs = data(fdgs)
# a. Subsect 1, observations with NA's
subset1 = which(is.na(fdgs$wgt) | is.na(fdgs$hgt))
# Take a sample of the data, including missing values
fdgs = data(fdgs)
# a. Subsect 1, observations with NA's
subset1 = which(is.na(fdgs$wgt) | is.na(fdgs$hgt))
# Load data and take a sample of the data, including missing values
data(fdgs)
# a. Subsect 1, observations with NA's
subset1 = which(is.na(fdgs$wgt) | is.na(fdgs$hgt))
# b. Subset 2, random sample of 1000 individuals
set.seed(1)
subset2 = sample((1:nrow(fdgs))[-subset1], 1000)
fdgs.sub = fdgs[c(subset1, subset2), ]
summary(fdgs.sub)
hgt.na = which(is.na(fdgs.sub$hgt))
hgt.na = which(is.na(fdgs.sub$hgt))
hgt.na
View(fdgs.sub)
library(mice)
library(INLA)
# Load data and take a sample of the data, including missing values
data(fdgs)
# a. Subsect 1, observations with NA's
subset1 = which(is.na(fdgs$wgt) | is.na(fdgs$hgt))
# b. Subset 2, random sample of 1000 individuals
set.seed(1)
subset2 = sample((1:nrow(fdgs))[-subset1], 1000)
# c. subset 1 + subset 2
fdgs.sub = fdgs[c(subset1, subset2), ]
summary(fdgs.sub)
hgt.na = which(is.na(fdgs.sub$hgt)) # children with missing height
wgt.na = which(is.na(fdgs.sub$wgt)) # children with missing weight
rownames(fdgs.sub)[wgt.na]
# 1. Prepare two response variables (height and weight)
n = nrow(fdgs.sub) # n = 1043
y = matrix(NA, nrow = 2 * n, ncol = 2) # 2086 times 2 matrix
y[1:n, 1] = fdgs.sub$hgt
y[n + 1:n, 2] = fdgs.sub$wgt
View(y)
# 2. Prepare the two intercepts
I = matrix(NA, nrow = 2 * n, ncol = 2)
I[1:n, 1] = 1
I[n + 1:n, 2] = 1
View(I)
I = matrix(NA, nrow = 2 * n, ncol = 2)
I[1:n, 1] = 1
I[n + 1:n, 2] = 1
View(I)
age.joint = rep(fdgs.sub$age, 2)
sex.joint = rep(fdgs.sub$sex, 2)
idx.age = rep(1:2, each = n)
idx.sex = rep(1:2, each = n)
idx.sex[1040:1045]
idx.sex[1040:1049]
joint.f = y ~ -1 + I + f(idx.sex, sex, model="iid2d", n=2) + f(idx.age, age, model = "iid2d", n = 2)
# Model fit
fdgs.joint = inla(joint.f, data = list(y = y, I = I, sex = sex.joint, age = age.joint,
idx.age = idx.age, idx.sex = idx.sex),
family = rep("gaussian", 2),
control.predictor = list(compute = TRUE))
# Coefficients for age and sex are part of the random effects of the model
fdgs.joint$summary.random$idx.sex # sex
fdgs.joint$summary.random$idx.age # age
inla.upgrade(testing=TRUE)
library(INLA)
inla.upgrade(testing=TRUE)
setwd("C:/Users/Monica/Dropbox/TEACHING/YEAR_2024/Bayes_Spatial_2024/Material/Session8.2")
library(renderthis)
library(webshot2)
to_pdf(from = "index.html", partial_slides = TRUE)
