mcmc.pars <- array(data = NA, dim = c(m, K, J))
mcmc.pars[ , , 3] <- mcmc$results[-(1:burn), (n+1):(n+K)]
z <- mcmc$results[-(1:burn), 1:n]
mcmc$results
mcmc.pars[ , , 1] <- mcmc$results[-(1:burn), (n+K+1):(n+2*K)]
View(z)
p <- array(data = NA, dim = c(m, n, K))
for (iter in 1:m){
for(i in 1:n){
kdist <- mcmc.pars[iter, , 3]*dnorm(x[i], mcmc.pars[iter, , 1],
+ sqrt(mcmc.pars[iter, , 2]))
skdist <- sum(kdist)
for(j in 1:K){
p[iter, i, j] = kdist[j]/skdist}}}
p
dim(p)
#load a toy example: MCMC output consists of the random beta model
# applied to a normal mixture of \code{K=2} components. The number
# of observations is equal to \code{n=5}. The number of MCMC samples
# is equal to \code{m=300}. The matrix of allocation probabilities
# is stored to matrix \code{p}.
data("mcmc_output")
data("mcmc_output", package = "bayesmix)
# mcmc parameters are stored to array \code{mcmc.pars}
mcmc.pars<-data_list$"mcmc.pars"
# mcmc.pars[,,1]: simulated means of the two components
# mcmc.pars[,,2]: simulated variances
# mcmc.pars[,,3]: simulated weights
# the computed allocation matrix is p
p<-data_list$"p"
run<-stephens(p)
# apply the permutations returned by typing:
reordered.mcmc<-permute.mcmc(mcmc.pars,run$permutations)
# reordered.mcmc[,,1]: reordered means of the components
# reordered.mcmc[,,2]: reordered variances
# reordered.mcmc[,,3]: reordered weights
data("mcmc_output", package = "bayesmix")
library("label.switching")
data("mcmc_output")
# mcmc parameters are stored to array \code{mcmc.pars}
mcmc.pars<-data_list$"mcmc.pars"
mcmc.pars[,,1]: simulated means of the two components
mcmc_output
data("mcmc_output")
data("mcmc_output")
View(data_list)
View(data_list)
install.packages("spdep")
install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/testing"), dep=TRUE)
remotes::install_github("inlabru-org/inlabru")
round(df$BI_aegypti),0)
uf_df <- data.frame(
"N"  = I(list(
c("AC", "AP", "AM", "PA", "RO", "RR", "TO")
)),
"NE" = I(list(
c("AL", "BA", "CE", "MA", "PB", "PE", "PI", "RN", "SE")
)),
"CW" = I(list(c(
"DF", "GO", "MT", "MS"
))),
"SE" = I(list(c(
"ES", "MG", "RJ", "SP"
))),
"S"  = I(list(c("PR", "RS", "SC")))
)
View(uf_df)
uf_df
uf_ls <- c()
for (i in region) {
uf_ls_temp <- unlist(uf_df[i])
uf_ls <- c(uf_ls, uf_ls_temp)
}
20*20
1/188.3
36/12
0.7*0.7
library(xaringan)
library(sf)
library(remotes)
remotes::install_github("geocompr/geocompkg",
upgrade = "ask", dependencies = TRUE, force = TRUE)
remotes::install_github("nowosad/spDataLarge")
warning()
warnings()
warnings()
remotes::install_github("nowosad/spDataLarge")
library(terra)
remotes::install_github("nowosad/spDataLarge")
library(spDataLarge)
remotes::install_github("jhelvy/renderthis", force=TRUE)
remotes::install_github('rstudio/chromote')
install.packages("webshot2")
library(renderthis)
library(webshot2)
library(xaringan)
setwd("~/Dropbox/TEACHING/YEAR_2023/Bayes_Spatial_2023/Material/Session8.1")
libary(xaringan)
library(xaringan)
# Sources the R file with all the relevant setup and commands
source("assets/setup.R")
# Stuff from 'xaringanExtra' (https://pkg.garrickadenbuie.com/xaringanExtra)
# This allows the use of panels (from 'xaringanExtra')
xaringanExtra::use_panelset()
# This allows to copy code from the slides directly
#xaringanExtra::use_clipboard()
# This freezes the frame for when there's a gif included
#xaringanExtra::use_freezeframe()
# Defines the path to the file with the .bib entries (in case there are references)
#bibfile=ReadBib("~/Dropbox/Books/INLABook/ShortCourse/VIBASS/Biblio.bib",check = FALSE)
bibfile=ReadBib("C:/Users/Monica/Dropbox/TEACHING/YEAR_2023/Bayes_Spatial_2023/Material/Biblio.bib",check = FALSE)
library(sp)
library(rgdal)
library(mapview)
library(leaflet)
data(meuse)
crs = CRS("+init=epsg:28992") # set original projection
coordinates(meuse) <- ~x+y
proj4string(meuse) <- crs
WGS84 = CRS("+init=epsg:4326")
#this funcion requires rgdal to be installed!
meuse2 = spTransform(meuse, WGS84)
mapview(meuse,
xcol = "Longitude",
ycol = "Latitude",
crs = 4326,
zcol = "zinc")
#meuse %>%
#  ggplot()+
#  geom_point(aes(x, y, col=zinc)) +
#  scale_color_viridis() +
#  theme(axis.ticks = element_blank(),
#         axis.text = element_blank(),
#        axis.title = element_blank())
book.rMatern <- function(n, coords, sigma=1, range, kappa = sqrt(8*nu)/range, variance = sigma^2, nu=1) {
m <- as.matrix(dist(coords))
m <- exp((1-nu)*log(2) + nu*log(kappa*m)-
lgamma(nu))*besselK(m*kappa, nu)
diag(m) <- 1
return(drop(crossprod(chol(variance*m),
matrix(rnorm(nrow(coords)*n), ncol=n))))
}
coords = expand.grid(x=seq(0,1,length=50),
y=seq(0,1,length=50))
set.seed(33)
sim1 = book.rMatern(n=1,
coords=coords,
sigma=1,
range=0.0942809,
nu=1)
sim2 = book.rMatern(n=1,
coords=coords,
sigma=1,
range=0.1663781,
nu=1)
sim3 = book.rMatern(n=1,
coords=coords,
sigma=1,
range=0.404061,
nu=1)
sim4 = book.rMatern(n=1,
coords=coords,
sigma=1,
range=0.7071068,
nu=1)
library(tidyverse)
data = data.frame(coords, sim1, sim2, sim3, sim4)
datalong = pivot_longer(data, sim1:sim4)
datalong$range = NA
datalong$range[datalong$name=="sim1"] = "range=0.09"
datalong$range[datalong$name=="sim2"] = "range=0.17"
datalong$range[datalong$name=="sim3"] = "range=0.40"
datalong$range[datalong$name=="sim4"] = "range=0.71"
library(viridis)
datalong %>%
ggplot()+
geom_raster(aes(x,y,fill=value)) +
scale_fill_viridis() +
facet_wrap(~range, nrow=1) +
coord_fixed()
library(INLA)
data(SPDEtoy)
dim(SPDEtoy)
head(SPDEtoy, n=3)
summary(SPDEtoy$y)
coords <- as.matrix(SPDEtoy[,1:2])
mesh0 <- inla.mesh.2d(loc = coords,
max.edge = 0.1)
coords <- as.matrix(SPDEtoy[,1:2])
mesh0 <- inla.mesh.2d(loc = coords,
max.edge = 0.1)
library(inlabru)
ggplot() +
gg(mesh0)
mesh1 <- inla.mesh.2d(loc = coords,
max.edge = c(0.1, 0.1)) #<<
mesh2 <- inla.mesh.2d(loc = coords,
max.edge = c(0.1, 0.2))#<<
mesh3 <- inla.mesh.2d(loc = coords,
max.edge = c(0.1, 0.2),
offset = c(0.4,0.1))#<<
mesh4 <- inla.mesh.2d(loc = coords,
max.edge = c(0.1, 0.2),
offset = c(0.1,0.4))#<<
domain <- matrix(cbind(c(0,1,1,0.7,0),
c(0,0,0.7,1,1)), ncol=2)
mesh5domain <- inla.mesh.2d(loc.domain = domain, #<<
max.edge = c(0.04, 0.2),
offset = c(0.1, 0.4))
mesh5 <- inla.mesh.2d(loc.domain = domain,
max.edge = c(0.04, 0.2),
cutoff = 0.5, #<<
offset = c(0.1, 0.4))
mesh6 <- inla.mesh.2d(loc.domain = domain,
max.edge = c(0.04, 0.2),
cutoff = 0.05,#<<
offset = c(0.1, 0.4))
set.seed(44)
loc = matrix(runif(20), 10, 2)
boundary = inla.nonconvex.hull(loc,
convex=0.2) #<<
meshNC <- inla.mesh.2d(loc = loc,
boundary = boundary, #<<
max.edge = c(0.04, 0.2))
A.est6 <- inla.spde.make.A(mesh = mesh6,
loc = coords)
dim(A.est6)
table(rowSums(A.est6>0))
table(rowSums(A.est6))
table(colSums(A.est6) > 0)
spde = inla.spde2.matern(mesh = mesh6)
spde$n.spde
formula = y ~ -1 + intercept + f(spatial.field, model = spde)
head(SPDEtoy)
nrow(SPDEtoy)
spde$n.spde
dim(SPDEtoy$y)
SPDEtoy$y
N <- nrow(SPDEtoy)
output6 <- inla(formula,
data = list(y = SPDEtoy$y, family="gaussian",
# intercept = rep(1,spde$n.spde),
intercept = rep(1,N),
spatial.field = 1:spde$n.spde),
control.predictor = list(A = A.est6, compute = TRUE))#<
output6 <- inla(formula,
data = list(y = SPDEtoy$y, family="gaussian",
intercept = rep(1,spde$n.spde),
# intercept = rep(1,N),
spatial.field = 1:spde$n.spde),
control.predictor = list(A = A.est6, compute = TRUE))#<<
spde$n.spde
output6 <- inla(formula,
data = list(y = SPDEtoy$y,
intercept = rep(1,spde$n.spde),
# intercept = rep(1,N),
spatial.field = 1:spde$n.spde),
control.fixed = prior.fixed,
control.predictor = list(A = A.est6, compute = TRUE))#<<
prior.fixed = list(mean.intecept = 0, prec.intercept = 1)
output6 <- inla(formula,
data = list(y = SPDEtoy$y,
intercept = rep(1,spde$n.spde),
# intercept = rep(1,N),
spatial.field = 1:spde$n.spde),
control.fixed = prior.fixed,
control.predictor = list(A = A.est6, compute = TRUE))
output6 <- inla(formula,
data = list(y = SPDEtoy$y,
intercept = rep(1,spde$n.spde),
# intercept = rep(1,N),
spatial.field = 1:spde$n.spde),
# control.fixed = prior.fixed,
control.predictor = list(A = A.est6, compute = TRUE))
A.est6
formula = y ~ 0 + intercept + f(spatial.field, model = spde)
output6 <- inla(formula,
data = list(y = SPDEtoy$y,
intercept = rep(1,spde$n.spde),
# intercept = rep(1,N),
spatial.field = 1:spde$n.spde),
# control.fixed = prior.fixed,
control.predictor = list(A = A.est6, compute = TRUE))#
output6 <- inla(formula,
data = list(y = SPDEtoy$y,
# intercept = rep(1,spde$n.spde),
intercept = rep(1,N),
spatial.field = 1:spde$n.spde),
# control.fixed = prior.fixed,
control.predictor = list(A = A.est6, compute = TRUE))#<<
output6 <- inla(formula,
data = list(y = SPDEtoy$y,
intercept = rep(1,spde$n.spde),
# intercept = rep(1,N),
spatial.field = 1:spde$n.spde),
control.predictor = list(A = A.est6, compute = TRUE),
control.fixed = prior.fixed)
output6 <- inla(formula,
data = list(y = SPDEtoy$y,
intercept = rep(1,spde$n.spde),
# intercept = rep(1,N),
spatial.field = 1:spde$n.spde),
control.predictor = list(A = A.est6, compute = TRUE),
inla.mode="experimental")#<<
output6 <- inla(formula,
data = list(y = SPDEtoy$y,
intercept = rep(1,spde$n.spde),
# intercept = rep(1,N),
spatial.field = 1:spde$n.spde),
control.predictor = list(A = A.est6, compute = TRUE),
verbose=TRUE)#<<
theta.ini = c(-4, 1)
output6 <- inla(formula,
data = list(y = SPDEtoy$y,
intercept = rep(1,spde$n.spde),
# intercept = rep(1,N),
spatial.field = 1:spde$n.spde),
control.predictor = list(A = A.est6, compute = TRUE),
control.mode = list(theta = theta.ini, restart = TRUE))
10ˆ(-2)
10^-2
10ˆ(-2)
priors = list(mean.intercept = 0, prec.intercept = 10^-2)
output6 <- inla(formula,
data = list(y = SPDEtoy$y,
intercept = rep(1,spde$n.spde),
# intercept = rep(1,N),
spatial.field = 1:spde$n.spde),
control.predictor = list(A = A.est6, compute = TRUE),
control.fixed = priors)
priors = list(mean.intercept = 0, prec.intercept = 1)
output6 <- inla(formula,
data = list(y = SPDEtoy$y,
intercept = rep(1,spde$n.spde),
# intercept = rep(1,N),
spatial.field = 1:spde$n.spde),
control.predictor = list(A = A.est6, compute = TRUE),
control.fixed = priors)
output6 <- inla(formula,
data = list(y = SPDEtoy$y,
# intercept = rep(1,spde$n.spde),
intercept = rep(1,N),
spatial.field = 1:spde$n.spde), # the spatial effect
control.predictor = list(A = A.est6, compute = TRUE),
control.fixed = priors)
inla.setOption(inla.mode="experimental")
output6 <- inla(formula,
data = list(y = SPDEtoy$y,
# intercept = rep(1,spde$n.spde),
intercept = rep(1,N),
spatial.field = 1:spde$n.spde), # the spatial effect
control.predictor = list(A = A.est6, compute = TRUE),
control.fixed = priors)
n = 100; a = 1; b = 1; tau = 100
z = rnorm(n)
eta = a + b*z
scale = exp(rnorm(n))
prec = scale*tau
y = rnorm(n, mean = eta, sd = 1/sqrt(prec))
data = list(y=y, z=z)
formula = y ~ 1+z
result = inla(formula, family = "gaussian", data = data)
summary(result)
# Sources the R file with all the relevant setup and commands
source("assets/setup.R")
# Stuff from 'xaringanExtra' (https://pkg.garrickadenbuie.com/xaringanExtra)
# This allows the use of panels (from 'xaringanExtra')
xaringanExtra::use_panelset()
# This allows to copy code from the slides directly
#xaringanExtra::use_clipboard()
# This freezes the frame for when there's a gif included
#xaringanExtra::use_freezeframe()
# Defines the path to the file with the .bib entries (in case there are references)
#bibfile=ReadBib("~/Dropbox/Books/INLABook/ShortCourse/VIBASS/Biblio.bib",check = FALSE)
bibfile=ReadBib("C:/Users/Monica/Dropbox/TEACHING/YEAR_2023/Bayes_Spatial_2023/Material/Biblio.bib",check = FALSE)
book.rMatern <- function(n, coords, sigma=1, range, kappa = sqrt(8*nu)/range, variance = sigma^2, nu=1) {
m <- as.matrix(dist(coords))
m <- exp((1-nu)*log(2) + nu*log(kappa*m)-
lgamma(nu))*besselK(m*kappa, nu)
diag(m) <- 1
return(drop(crossprod(chol(variance*m),
matrix(rnorm(nrow(coords)*n), ncol=n))))
}
coords = expand.grid(x=seq(0,1,length=50),
y=seq(0,1,length=50))
set.seed(33)
sim1 = book.rMatern(n=1,
coords=coords,
sigma=1,
range=0.0942809,
nu=1)
sim2 = book.rMatern(n=1,
coords=coords,
sigma=1,
range=0.1663781,
nu=1)
sim3 = book.rMatern(n=1,
coords=coords,
sigma=1,
range=0.404061,
nu=1)
sim4 = book.rMatern(n=1,
coords=coords,
sigma=1,
range=0.7071068,
nu=1)
library(tidyverse)
data = data.frame(coords, sim1, sim2, sim3, sim4)
datalong = pivot_longer(data, sim1:sim4)
datalong$range = NA
datalong$range[datalong$name=="sim1"] = "range=0.09"
datalong$range[datalong$name=="sim2"] = "range=0.17"
datalong$range[datalong$name=="sim3"] = "range=0.40"
datalong$range[datalong$name=="sim4"] = "range=0.71"
library(viridis)
datalong %>%
ggplot()+
geom_raster(aes(x,y,fill=value)) +
scale_fill_viridis() +
facet_wrap(~range, nrow=1) +
coord_fixed()
library(INLA)
inla.setOption(inla.mode="experimental") # use the most recent computational methodology
data(SPDEtoy)
dim(SPDEtoy)
head(SPDEtoy, n=3)
summary(SPDEtoy$y)
coords <- as.matrix(SPDEtoy[,1:2])
mesh0 <- inla.mesh.2d(loc = coords,
max.edge = 0.1)
coords <- as.matrix(SPDEtoy[,1:2])
mesh0 <- inla.mesh.2d(loc = coords,
max.edge = 0.1)
library(inlabru)
ggplot() +
gg(mesh0)
mesh1 <- inla.mesh.2d(loc = coords,
max.edge = c(0.1, 0.1)) #<<
mesh2 <- inla.mesh.2d(loc = coords,
max.edge = c(0.1, 0.2))#<<
mesh3 <- inla.mesh.2d(loc = coords,
max.edge = c(0.1, 0.2),
offset = c(0.4,0.1))#<<
mesh4 <- inla.mesh.2d(loc = coords,
max.edge = c(0.1, 0.2),
offset = c(0.1,0.4))#<<
domain <- matrix(cbind(c(0,1,1,0.7,0),
c(0,0,0.7,1,1)), ncol=2)
mesh5domain <- inla.mesh.2d(loc.domain = domain, #<<
max.edge = c(0.04, 0.2),
offset = c(0.1, 0.4))
mesh5 <- inla.mesh.2d(loc.domain = domain,
max.edge = c(0.04, 0.2),
cutoff = 0.5, #<<
offset = c(0.1, 0.4))
mesh6 <- inla.mesh.2d(loc.domain = domain,
max.edge = c(0.04, 0.2),
cutoff = 0.05,#<<
offset = c(0.1, 0.4))
set.seed(44)
loc = matrix(runif(20), 10, 2)
boundary = inla.nonconvex.hull(loc,
convex=0.2) #<<
meshNC <- inla.mesh.2d(loc = loc,
boundary = boundary, #<<
max.edge = c(0.04, 0.2))
A.est6 <- inla.spde.make.A(mesh = mesh6,
loc = coords)
dim(A.est6)
table(rowSums(A.est6>0))
table(rowSums(A.est6))
table(colSums(A.est6) > 0)
spde = inla.spde2.matern(mesh = mesh6)
spde$n.spde
formula = y ~ 0 + intercept + f(spatial.field, model = spde)
output6 <- inla(formula,
data = list(y = SPDEtoy$y, intercept = rep(1,spde$n.spde),
#  intercept = rep(1,N),
spatial.field = 1:spde$n.spde), # the spatial effect
control.predictor = list(A = A.est6, compute = TRUE))
output6 <- inla(formula,
data = list(y = SPDEtoy$y, intercept = rep(1,spde$n.spde),
#  intercept = rep(1,N),
spatial.field = 1:spde$n.spde), # the spatial effect
control.predictor = list(A = A.est6, compute = TRUE),
control.fixed = priors,
control.inla = list(strategy = "gaussian", int.strategy = "eb")
)
priors = list(mean.intercept = 0, prec.intercept = 1)
output6 <- inla(formula,
data = list(y = SPDEtoy$y, intercept = rep(1,spde$n.spde),
#  intercept = rep(1,N),
spatial.field = 1:spde$n.spde), # the spatial effect
control.predictor = list(A = A.est6, compute = TRUE),
control.fixed = priors,
control.inla = list(strategy = "gaussian", int.strategy = "eb"))
N <- nrow(SPDEtoy)
priors = list(mean.intercept = 0, prec.intercept = 1)
output6 <- inla(formula,
data = list(y = SPDEtoy$y, #intercept = rep(1,spde$n.spde),
intercept = rep(1,N),
spatial.field = 1:spde$n.spde), # the spatial effect
control.predictor = list(A = A.est6, compute = TRUE),
control.fixed = priors,
control.inla = list(strategy = "gaussian", int.strategy = "eb"))#<<
output6 <- inla(formula,
data = list(y = SPDEtoy$y, #intercept = rep(1,spde$n.spde),
intercept = rep(1,N),
spatial.field = 1:spde$n.spde), # the spatial effect
control.predictor = list(A = A.est6, compute = TRUE),
control.fixed = priors,
control.inla = list(diagonal = 100, strategy = "gaussian", int.strategy = "eb"))
