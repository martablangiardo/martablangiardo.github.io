---
title: "Practical 3 - INLA-SPDE for geostatistical data "
author: "Spatial and Spatio-Temporal Bayesian Models with `R-INLA`"
header-includes:
    - \usepackage{bm}
output:
  html_document:
    toc: true
    toc_float: true
bibliography: biblio.bib
---
  
\pagenumbering{gobble} 
\pagenumbering{arabic} 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE, fig.align = "center")
```

## 1. Introduction 
In this practical we will make use of INLA-SPDE and `inlabru` for implementing a spatial model and performing spatial prediction. We will use a dataset related to **daily temperature measurements** automatically collected at 123 meteorological stations in Croatia on 19,th July 2006. Moreover, information about elevation (in mt) and distance in km from the coastline are available on a regular grid. The data are part of a bigger dataset available from http://book.spatial-analyst.net/HRtemp2006 and containing information for all days in 2006. In the following we will implement a spatial model with temperature as response variable and elevation and distance as covariates.


The data are included in the workspace `temperature.croatia.Rdata` which can be loaded in `R` via 
```{r}
library(tidyverse)
library(INLA)
library(inlabru)
library(viridis) #for colors
# Remove old objects
remove(list=ls())
# Remember to set the correct working directory
load("temperature.croatia.Rdata")
ls()
```


## 2. Explore and analyse the data 
The workspace contains two `data.frame` objects: 

1. The first is named `stations_data` and contains information about the 123 meteorological stations. Exploring the data
```{r}
glimpse(stations_data)
```

we see that the it includes 10 variables. The important variables for the application are: 

- elevation (`HRdem`)
- distance from the coastline (`HRdsea`)
- latitude (`Lat`) 
- longitude (`Lon`)

2. The second data frame is named `grid_cov` and contains the same relevant information for a regular grid of 1250 points (25 $\times$ 50):
```{r}
glimpse(grid_cov)
```

The regular grid (gray points) together with the monitor stations (red points) are represented in the following plot:
```{r}
ggplot()+
  geom_point(data = grid_cov, aes(Lon,Lat),
             col = "gray") +
  geom_point(data = stations_data, aes(Lon,Lat),
             col = "red", size = 2) +
  theme_bw()
```

We plot also the distribution of the response variable `MDTEMP` (histogram + density function):
```{r}
stations_data %>% 
  ggplot() +
  geom_histogram(aes(MDTEMP, after_stat(density)),bins = 13, alpha=0.5) +
  geom_density(aes(MDTEMP)) 
```

Looking at the plot  and using the **Shapiro-Wilk Normality test**
```{r}
shapiro.test(stations_data$MDTEMP)
```
we can conclude that the response variable is approximately Normal.

It can also be useful to plot the values of the covariate `HRdem` (elevation) for both the monitoring station sites and the points of the regular grid. To do this we will use the quantiles of the distributions to create a `factor` variable. 

```{r}
#HRdem monitoring stations
stations_data %>% 
  mutate(HRdem.factor = cut(HRdem,
                    breaks = quantile(HRdem),
                    include.lowest = TRUE,
                    right = TRUE)) %>% 
  ggplot() +
  geom_point(aes(Lon, Lat, col = HRdem.factor), size = 2) +
  scale_color_brewer(palette = "YlGn") +
  theme_bw()
```

```{r}
#HRdem grid points
grid_cov %>% 
  mutate(HRdem.factor = cut(HRdem,
                    breaks = unique(quantile(HRdem)), #the first and the second quantiles are equal
                    include.lowest = TRUE,
                    right = TRUE)) %>% 
  ggplot() +
  geom_point(aes(Lon, Lat, col = HRdem.factor), size = 2) +
  scale_color_brewer(palette = "YlGn") +
  theme_bw()
```

## 3. Model

We assume the following spatial model
\[
y_i \sim \text{Normal}(\eta_i, \sigma^2_e) \qquad i=1,\ldots, 123
\]
where $\sigma^{2}_e$ is the variance of the zero mean measurement error $e_i$ which is supposed to be normally distributed and independent on $e_{j}$ for each $i\neq j$ and the linear predictor given by
\[
\eta_i = \beta_0+ \beta_1 \texttt{HRdem}_i + \xi_i
\]
including an intercept $\beta_0$, a linear effect $\beta_1$ of elevation and the spatial random effect $\xi_i$ which is a priori a Matern GF.



## 4. Mesh construction
The first step for implementing the SPDE approach is the definition of the mesh. Since in this case the Croatia borders are quite irregular we use the new `inla.nonconvex.hull` function:
```{r}
bnd = inla.nonconvex.hull(cbind(stations_data$Lon,stations_data$Lat),
                          convex=0.25)

croatia.mesh = inla.mesh.2d(loc = cbind(stations_data$Lon,
                                       stations_data$Lat),
                          boundary = bnd,
                          offset = c(1, 2),
                          max.edge = c(3, 8),
                          cutoff = 0.3)
```


The mesh plot can be obtained using standard code
```{r}
plot(croatia.mesh,asp=1)
points(stations_data$Lon, stations_data$Lat, pch=21, cex=1.2, bg="white",col=1)
```
or using the `inlabru` package function `gg` (using `ggplot` style)
```{r}
ggplot() + 
  gg(croatia.mesh) +
  geom_point(data = stations_data, aes(Lon, Lat))
```

## 5. Model fitting with `inla.stack`
We use `R-INLA` and the `inla.stack` funtion to estimate the parameters of the given model where $\{\bm  \xi,\beta_0,\beta_1\}$ and the hyperparameter vector contains $\sigma^2_e$, the spatial variance $\sigma^2$ and the spatial range $r$. 


1. We start by creating the SPDE model object
```{r}
spde = inla.spde2.matern(mesh = croatia.mesh)
```
The number of vertices of the mesh can be retrieved with 
```{r}
spde$n.spde
```

2. We define the projector matrix $\bm A$ and the `inla.stack` object for the **estimation** part: 
```{r}
A.est = inla.spde.make.A(croatia.mesh,
                         loc = as.matrix(cbind(stations_data$Lon,stations_data$Lat)))
dim(A.est)


stack.est = inla.stack(data = list(temp = stations_data$MDTEMP),
                       A = list(A.est, 1, 1),
                       effects = list(spatial.index = 1:spde$n.spde,
                                      Intercept = rep(1, nrow(stations_data)),
                                      HRdem = stations_data$HRdem), 
                       tag="est")
```

3. We define now the projector matrix $\bm A$ and the `inla.stack` object for the **prediction** part considering the `grid_cov` regular grid:
```{r}
A.pred = inla.spde.make.A(croatia.mesh,
                          loc = cbind(grid_cov$Lon,grid_cov$Lat))
dim(A.pred)

stack.pred = inla.stack(data = list(temp = NA), 
                        A = list(A.pred, 1, 1),
                        effects = list(spatial.index = 1:spde$n.spde,
                                       Intercept = rep(1, nrow(grid_cov)),
                                       HRdem = grid_cov$HRdem),
                        tag = "pred")
```

4. Finally we join all the `inla.stack` objects, define the `formula` and run the `inla` function (including also the computation of DIC):
```{r}
fullstack = inla.stack(stack.est, stack.pred)

formula = temp ~ -1 + Intercept + HRdem + f(spatial.index, model = spde)

output = inla(formula,
       data = inla.stack.data(fullstack, spde = spde),
       family = "gaussian",
       control.predictor = list(A = inla.stack.A(fullstack), compute = TRUE),
       control.compute = list(dic = TRUE))
```


We extract now the posterior distribution of the **fixed effects** as follows
```{r}
output$summary.fixed
```
and we note the significative and negative effect of elevation (even if small). It is  also possible to plot the marginal posterior of intercept and elevation:
```{r}
inla.smarginal(output$marginals.fixed$Intercept) %>% 
  dplyr::bind_rows() %>%  #from list to data frame
  ggplot() +
  geom_line(aes(x,y)) +
  ggtitle("Intercept")

inla.smarginal(output$marginals.fixed$HRdem) %>% 
  dplyr::bind_rows() %>%  #from list to data frame
  ggplot() +
  geom_line(aes(x,y)) +
  ggtitle("Elevation")
```

Then we compute the posterior summaries (mean, standard deviation and 0.025, 0.5, 0.975 quantiles) about the Gaussian observation variance $\sigma^2_e$ by transforming the precision posterior distribution with `inla.tmarginal`:
```{r}
sigma2e_marg =
  inla.tmarginal(function(x) 1/x,
  output$marginals.hyperpar$"Precision for the Gaussian observations")

inla.zmarginal(sigma2e_marg)
```

The posterior summaries of the spatial parameters can be extracted from the output by means of the `inla.spde2.result` function:
```{r}
output.field = inla.spde2.result(inla = output, 
                                 name = "spatial.index",
                                 spde = spde,
                                 do.transf = TRUE)
```
Then we use the following code to retrieve the piece of information we need for the spatial variance and the range:
```{r}
var.nom.marg = output.field$marginals.variance.nominal[[1]]
inla.zmarginal(var.nom.marg)

range.nom.marg = output.field$marginals.range.nominal[[1]]
inla.zmarginal(range.nom.marg)
```

When interpreting the posterior mean of the range, consider that the maximum distance between station sites is 5.75.

Finally we extract the DIC through
```{r}
output$dic$dic
```
This information will be used later for model comparison.



## 6. Model fitting with `inlabru`

We first transform the `stations_data` `data.frame` into a `SpatialPointsDataFrame`:
```{r}
coordinates(stations_data) = c("Lon","Lat")
class(stations_data)
```

We then define the model components
```{r}
cmp1 = MDTEMP ~ Intercept(1) + HRdem + s.field(main = coordinates, model = spde) 
```

and the likelihood:
```{r}
lik1 = like(formula = MDTEMP ~ Intercept + HRdem + s.field,
             family = "gaussian",
             data = stations_data)
```

And finally run the `bru` function:
```{r}
outputbru <- bru(cmp1, lik1)
```

And now let's compare the output for the fixed effects and the hyperparameters from the two approaches:
```{r}
output$summary.fixed
outputbru$summary.fixed

output$summary.hyperpar
outputbru$summary.hyperpar

```

## 7. Mapping spatial prediction with `inla.stack`

We will now use the linear predictor posterior mean to create a map of the temperature field for the regular grid covering Croatia. To access the posterior marginal distributions of predictions at the target grid locations, we extract with the `inla.stack.index` function the corresponding data indexes from the full stack object using the corresponding tags:

```{r}
index.pred = inla.stack.index(stack = fullstack, "pred")$data
```

Then we save the posterior mean and sd with 
```{r}
post.mean.pred = output$summary.linear.predictor[index.pred, "mean"]
post.mean.sd = output$summary.linear.predictor[index.pred, "sd"]
```

and reshape these objects as matrix with the grid dimension (25 $\times$ 50):
```{r}
library(fields)


image.plot(matrix(post.mean.pred, 25, 50), col = viridis(64))
image.plot(matrix(post.mean.sd, 25, 50), col = viridis(64))
```

## 8. Mapping spatial prediction with `inlabru`
We transform first of all the `grid_cov` `data.frame` object into a  `SpatialPixelsDataFrame`:
```{r}
coordinates(grid_cov) = c("Lon", "Lat")
gridded(grid_cov) = TRUE
class(grid_cov)
```

Then we use the `predict` function from `inlabru` to compute some summary statistics (using MCMC sampling) for the linear predictor (including the intercept, the effect of altitude and the spatial field):
```{r}
pred = predict(outputbru, grid_cov,
              ~ Intercept + HRdem + s.field,
              seed = 1)
head(pred)
```

We plot here below the posterior mean and standard deviation of the linear predictor:
```{r}
ggplot() + 
  gg(pred, aes(Lon, Lat, fill = mean)) +
  ggtitle("Posterior mean") + 
  coord_fixed() +
  scale_fill_viridis()
ggplot() + 
  gg(pred, aes(Lon, Lat, fill = sd)) +
  ggtitle("Posterior SD") + 
  coord_fixed() +
  scale_fill_viridis()
```


## 9. Model comparison
We want now to implement a new spatial model including in the fixed effects also the covariate `HRdsea` (distance from the see). We will then compare the two model with the DIC index.
The following code (not commented) implemented the second model using `inlabru`:
```{r}
cmp2 = MDTEMP ~ 1 + HRdem + HRdsea + s.field(main = coordinates, model = spde) 
lik2 = like(formula = MDTEMP ~ Intercept + HRdem + HRdsea + s.field,
             family = "gaussian",
             data = stations_data)
outputbru2 = bru(cmp2, lik2)
```
Comparing the DIC values 
```{r}
outputbru$dic$dic
outputbru2$dic$dic
```
we can conclude that the two models are almost identical.





