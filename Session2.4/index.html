<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Session 2.4: advanced INLA features</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <!-- (Re)Defines a bunch of LaTeX commands that can then be used directly in the .Rmd file as '\command{...}' -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      TeX: {
        /* This enables color macros */
        extensions: ["color.js"],
        Macros: {
          /* Probability & mathematical symbols */
          Pr: "{\\style{font-family:inherit; font-size: 110%;}{\\text{Pr}}}",
          exp: "{\\style{font-family:inherit; font-size: 105%;}{\\text{exp}}}",
          log: "{\\style{font-family:inherit; font-size: 105%;}{\\text{log}}}",
          ln: "{\\style{font-family:inherit; font-size: 105%;}{\\text{ln}}}",
          logit: "{\\style{font-family:inherit; font-size: 100%;}{\\text{logit}}}",
          HR: "{\\style{font-family:inherit; font-size: 105%;}{\\text{HR}}}",
          OR: "{\\style{font-family:inherit; font-size: 105%;}{\\text{OR}}}",
          E: "{\\style{font-family:inherit; font-size: 105%;}{\\text{E}}}",
          Var: "{\\style{font-family:inherit; font-size: 105%;}{\\text{Var}}}",
          Cov: "{\\style{font-family:inherit; font-size: 105%;}{\\text{Cov}}}",
          Corr: "{\\style{font-family:inherit; font-size: 105%;}{\\text{Corr}}}",
          DIC: "{\\style{font-family:inherit; font-size: 105%;}{\\text{DIC}}}",
          se: "{\\style{font-family:inherit; font-size: 100%;}{\\text{se}}}",
          sd: "{\\style{font-family:inherit; font-size: 100%;}{\\text{sd}}}",
          kld: "{\\style{font-family:inherit; font-size: 100%;}{\\text{kld}}}",
          /* Distributions */
          dnorm: "{\\style{font-family:inherit;}{\\text{Normal}}}",
          dt: "{\\style{font-family:inherit;}{\\text{t}}}",
          ddirch: "{\\style{font-family:inherit;}{\\text{Dirichlet}}}",
          dmulti: "{\\style{font-family:inherit;}{\\text{Multinomial}}}",
          dbeta: "{\\style{font-family:inherit;}{\\text{Beta}}}",
          dgamma: "{\\style{font-family:inherit;}{\\text{Gamma}}}",
          dbern: "{\\style{font-family:inherit;}{\\text{Bernoulli}}}",
          dbin: "{\\style{font-family:inherit;}{\\text{Binomial}}}",
          dpois: "{\\style{font-family:inherit;}{\\text{Poisson}}}",
          dweib: "{\\style{font-family:inherit;}{\\text{Weibull}}}",
          dexp: "{\\style{font-family:inherit;}{\\text{Exponential}}}",
          dlnorm: "{\\style{font-family:inherit;}{\\text{logNormal}}}",
          dunif: "{\\style{font-family:inherit;}{\\text{Uniform}}}",
          /* LaTeX formatting */
          bm: ["{\\boldsymbol #1}",1],
          /* These create macros to typeset numbers in maths with the basic font */
          0: "{\\style{font-family:inherit; font-size: 105%;}{\\text{0}}}",
          1: "{\\style{font-family:inherit; font-size: 105%;}{\\text{1}}}",
          2: "{\\style{font-family:inherit; font-size: 105%;}{\\text{2}}}",
          3: "{\\style{font-family:inherit; font-size: 105%;}{\\text{3}}}",
          4: "{\\style{font-family:inherit; font-size: 105%;}{\\text{4}}}",
          5: "{\\style{font-family:inherit; font-size: 105%;}{\\text{5}}}",
          6: "{\\style{font-family:inherit; font-size: 105%;}{\\text{6}}}",
          7: "{\\style{font-family:inherit; font-size: 105%;}{\\text{7}}}",
          8: "{\\style{font-family:inherit; font-size: 105%;}{\\text{8}}}",
          9: "{\\style{font-family:inherit; font-size: 105%;}{\\text{9}}}",
          /* Health economics quantities */
          icer: "{\\style{font-family:inherit; font-size: 100%;}{\\text{ICER}}}",
          nb: "{\\style{font-family:inherit; font-size: 100%;}{\\text{NB}}}",
          ol: "{\\style{font-family:inherit; font-size: 100%;}{\\text{OL}}}",
          ceac: "{\\style{font-family:inherit; font-size: 100%;}{\\text{CEAC}}}",
          evpi: "{\\style{font-family:inherit; font-size: 100%;}{\\text{EVPI}}}",
          evppi: "{\\style{font-family:inherit; font-size: 100%;}{\\text{EVPPI}}}",
          evsi: "{\\style{font-family:inherit; font-size: 100%;}{\\text{EVSI}}}"
        }
      }
    });
    </script>
    <link rel="stylesheet" href="assets/beamer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">




class: title-slide

# Session 2.4: advanced INLA features&lt;span style="display:block; margin-top: 10px ;"&gt;&lt;/span&gt; 

## 

###     

### VIBASS, University of Valencia 

&lt;!-- Can also separate the various components of the extra argument 'params', eg as in 
### VIBASS, University of Valencia, 21 July 2022, Spatial and Spatio-Temporal Bayesian Models with `R-INLA`
--&gt;

21 July 2022



---

layout: true  

.my-footer[ 
.alignleft[ 
&amp;nbsp; &amp;copy; Marta Blangiardo | Michela Cameletti 
]
.aligncenter[
Spatial and Spatio-Temporal Bayesian Models with `R-INLA` 
]
.alignright[
VIBASS, 21 Jul 2022 
]
] 



&lt;style type="text/css"&gt;
.scrollable {
  height: 80%;
  overflow-y: auto;
} 
&lt;/style&gt;

---

# Learning Objectives

At the end of this session you should be able to:

&lt;span style="display:block; margin-top: 20px ;"&gt;&lt;/span&gt;

- implement a joint model with multiple likelihoods by using `R-ILA` and `inlabru`;


&lt;span style="display:block; margin-top: 20px ;"&gt;&lt;/span&gt;


- use the `copy` feature with `R-INLA`;


&lt;span style="display:block; margin-top: 30px ;"&gt;&lt;/span&gt;

- Implement with `inlabru` a model with two likelihoods and a shared spatial effect



The topics treated in this lecture can be partially found in **Chapter 8** of the INLA book.  

---

# Outline 

&lt;span style="display:block; margin-top: 30px ;"&gt;&lt;/span&gt;

1\. [Joint model with multiple likelihoods](#jointmodel)

&lt;span style="display:block; margin-top: 30px ;"&gt;&lt;/span&gt;

2\. [The `copy` feature](#copyfeature)


&lt;span style="display:block; margin-top: 30px ;"&gt;&lt;/span&gt;

3\. [Two likelihoods model with shared spatial effect using `inlabru`](#stinlabru)


---

name: jointmodel
  
&lt;span style="display:block; margin-top: 250px ;"&gt;&lt;/span&gt;

.myblue[.center[.huge[
**Joint model with multiple likelihoods**]]]



---

# Multiple likelihoods

- In many situations you need to combine data from different sources and/or differente characteristics. For example:
&lt;span style="display:block; margin-top: 10px ;"&gt;&lt;/span&gt;
  - a subset of the data follows a Gaussian distribution
and the other follows a Poisson distribution)
&lt;span style="display:block; margin-top: 10px ;"&gt;&lt;/span&gt;
  - the data come from the same distribution but with different hyperparameters (e.g. one subset of the data comes from a Gaussian distribution with precision `\(\tau_1\)` and the other from a Gaussian with precision `\(\tau_2\)`).

&lt;span style="display:block; margin-top: 30px ;"&gt;&lt;/span&gt;
- In this case we need to be able to handle **multiple likelihoods** when implementing the **joint model**.


&lt;span style="display:block; margin-top: 30px ;"&gt;&lt;/span&gt;

- In `R-INLA` this requires to have a particular structure for the data. For example, in the case of two likelihoods with two responses `\(\bm y_1 = (y_{11},\ldots,y_{1n})\)` and `\(\bm y_2 = (y_{21},\ldots,y_{2m})\)`, the data should be structured in a 2-columns matrix like the following:

`$$\begin{bmatrix} y_{11}  &amp; NA \\ \ldots &amp; NA \\  y_{1n} &amp; NA\\ NA &amp; y_{21} \\ NA &amp; \ldots \\ NA &amp; y_{2m} \end{bmatrix}$$`

---

# Two likelihoods model: example

This example shows how to use information from two data sources (Binomial and Poisson distribution) to estimate the effect of a common covariate `\(x\)` and of two different intercepts.

&lt;span style="display:block; margin-top: 30px ;"&gt;&lt;/span&gt;

- **Likelihood 1**: 
`$$y_{1i} \sim Bin\left(n=1, p_i=\frac{\eta_{1i}}{1+\eta_{1i}}\right) \qquad i=1,\ldots,n$$` 
&lt;span style="display:block; margin-top: 10px ;"&gt;&lt;/span&gt;
where `\(\eta_{1i} = \alpha + \beta_1 x_{1i}\)`

&lt;span style="display:block; margin-top: 30px ;"&gt;&lt;/span&gt;

- **Likelihood 2**: 
`$$y_{2i} \sim Poisson\left(\lambda_i=\exp(\eta_{2i})\right)\qquad i= 1,\ldots,m$$`
&lt;span style="display:block; margin-top: 10px ;"&gt;&lt;/span&gt;
where `\(\eta_{2i} = \gamma + \beta_1 x_{2i}\)`

---

# Two likelihoods model: data simulation

- We simulate `\(n=100\)` data from the **Binomial** distribution:

```r
&gt; n = 100
&gt; x1 = runif(n)
&gt; eta1 = 1 + x1 #linear predictor 1
&gt; y1 = rbinom(n, size = 1, prob = exp(eta1)/(1+exp(eta1)))
&gt; df1 = data.frame(x = x1, y = y1)
```

- We simulate `\(m=200\)` data from the **Poisson** distribution

```r
&gt; m = 200
&gt; x2 = runif(m) 
&gt; eta2 = 2 + x2 #linear predictor 2
&gt; y2 = rpois(m, exp(eta2))
&gt; df2 = data.frame(x = x2, y = y2)
```

---
# Two likelihoods model: implementation with `inla`

- Define the **block matrix** for the two response variables:

```r
&gt; y = matrix(NA, n+m, 2)  
&gt; y[1:n, 1] = y1  # first column
&gt; y[(n+1):(n+m), 2] = y2  #second column
&gt; Ntrials = c(rep(1,n), rep(NA, m)) # required only for Binomial data
```

- Define the **block matrix** for the two intercepts:

```r
&gt; intercept1 = numeric(n+m) #empty vector
&gt; intercept1[1:n] = 1
&gt; intercept1[(n+1):(n+m)] = NA
&gt; 
&gt; intercept2 = numeric(n+m) #empty vector
&gt; intercept2[1:n] = NA
&gt; intercept2[(n+1):(n+m)] = 1
```

- With this approach every row has only a single observed value.
- Covariates and latent effects can be indexed from 1 to `\(n+m\)`. When a covariate or effect must only affect observations in a single likelihood, the values of the indices for the other likelihood must be set to `NA`.

---

# Two likelihoods model: implementation with `inla`

- Fit the model with `inla`:

```r
&gt; # Covariate vector
&gt; x = c(x1, x2)
&gt; 
&gt; formula = y  ~ -1 + intercept1 + intercept2 + x #all the terms
&gt; 
&gt; library(INLA)
&gt; output = inla(formula,
*+               data = list(y = y, intercept1 = intercept1,
+                           intercept2 = intercept2, x = x), 
*+               family = c("binomial", "Poisson"),
+               Ntrials = Ntrials)
&gt; 
&gt; output$summary.fixed[,c("mean","0.025quant","0.975quant")]
```

```
                mean 0.025quant 0.975quant
intercept1 0.9557212  0.4789041   1.472898
intercept2 2.0236658  1.9330591   2.112957
x          0.9511763  0.8114298   1.091260
```

---

# Two likelihoods model: implementation with `inlabru`

- Define the model components and the likelihoods:

```r
&gt; cmp = y ~ Intercept1(1) + Intercept2(1) + x
&gt; 
&gt; library(inlabru)
&gt; like1 = like(formula = y ~ Intercept1 + x,
+              family = "binomial",
+              data = df1, 
+              Ntrials = rep(1, nrow(df1)))
&gt; 
&gt; like2 = like(formula = y ~ Intercept2 + x,
+              family = "Poisson",
+              data = df2)
```

- Fit the model with `inlabru`:

```r
&gt; outputbru = bru(cmp, like1, like2)
&gt; outputbru$summary.fixed[,c("mean","0.025quant","0.975quant")]
```

```
                mean 0.025quant 0.975quant
Intercept1 0.9557213  0.4789015   1.472903
Intercept2 2.0236658  1.9330383   2.112979
x          0.9511766  0.8114168   1.091274
```

---

name: copyfeature
  
&lt;span style="display:block; margin-top: 250px ;"&gt;&lt;/span&gt;

.myblue[.center[.huge[
**The `copy` feature**]]]


---

# The `copy` feature

-  In `R-INLA` when we have a model defined with the following formula

```r
&gt; formula = y ~ f(idx1, model1, ...) + f(idx2, model2, ...)
```
it means that only one element from each sub-model contributes to the linear predictor for each observation. This means that the linear predictor is connected to only one element of the random effect `idx1` and to only one element of the random effect `idx2`.

&lt;span style="display:block; margin-top: 30px ;"&gt;&lt;/span&gt;
- This is not sufficient when an element of a model is needed more than once for each observation or when the same effect is shared among two or more linear predictors (and will be estimated by using two or more parts of the dataset). 

&lt;span style="display:block; margin-top: 10px ;"&gt;&lt;/span&gt;
- The solution for this is the `copy` feature. Formally, it defines a copy of a generic effect `\(\theta\)` as `$$\theta^{\star}=\beta \theta + \epsilon$$` where `\(\epsilon \sim \text {Normal}(0, b)\)`, with `\(b\)`  being a large and fixed value ($\epsilon$ is a tiny error), and `\(\beta\)` is a hyperparameter. By fixing `\(\beta=1\)`, it means that `\(\theta^{\star}\)`  is an exact copy of `\(\theta\)`. According to the specification of the `fixed` option (`TRUE` or `FALSE`), the hyperparameter `\(\beta\)` is kept fixed or estimated.

&lt;span style="display:block; margin-top: 10px ;"&gt;&lt;/span&gt;
- Several copies of the same effect can be created and all will share the same hyperparameters. 

---

# The `copy feature`: example

The following example considers a Gaussian likelihood whose linear predictor includes two correlated random effects - `\(a\)` and `\(b\)` - coming from a bivariate Normal distribution: 

&lt;span style="display:block; margin-top: 10px ;"&gt;&lt;/span&gt;
`$$y_i \sim Normal(\eta_i,\tau^{-1}), \qquad i=1,\ldots,n$$` 
where the linear predictor is given by
`$$\eta_i=a_i+b_iz_i$$`
and
`$$(a_i,b_i)\overset{iid}\sim Normal(\bm 0, \bm Q^{-1})$$`
The term `\(z_i\)` refers to a known covariate. 

&lt;span style="display:block; margin-top: 20px ;"&gt;&lt;/span&gt;
In `R-INLA` the bivariate Gaussian model is implemented with
`f(index, model = "iid2d", ...)`
but this does not allow to have each `\(\eta_i\)` connected to two elements of the same (bi-variate Gaussian) model. We will use `copy`!

---

# The `copy feature`: data simulation
We simulate `\(n=1000\)` values from the previous model with `\(\tau= \tau_a=\tau_b=1\)`, `\(\rho_{ab}=0.8\)`.

```r
&gt; set.seed(3)
&gt; n = 1000
&gt; z = rnorm(n) #covariate
&gt; 
&gt; Sigma = matrix(c(1, 0.8, 0.8, 1), 2, 2) # var-cov matrix
&gt; library(mvtnorm)
&gt; ab = rmvnorm(n, sigma = Sigma) #bivariate normal
&gt; a = ab[, 1]
&gt; b = ab[, 2]
&gt; 
&gt; eta = a + b * z #linear predictor
&gt; y = eta + rnorm(n, sd = 1) #response variable
```

---

# The `copy` feature: implementation with `inla`
The `iid2d` model is represented internally as one vector of length `\(2n\)`. We set the indexes correspondingly and define the formula with the `copy` feature:

```r
&gt; i = 1 : n # use only the first n elements (a_1, ..., a_n)
&gt; j = (n+1) : (2*n) # use only the last n elements (b_1, ..., b_n)
&gt; 
&gt; formula = y ~ -1 + f(i, model = "iid2d", n = 2*n) + f(j, z, copy = "i",fixed=TRUE) 
```

And finally run inla:

```r
&gt; result = inla(formula,
+               data = data.frame(y = y, z = z, i = i, j = j),
+               family = "gaussian")
&gt; result$summary.hyperpar[,c("mean", "0.025quant", "0.975quant")]
```

```
                                             mean 0.025quant 0.975quant
Precision for the Gaussian observations 1.0757964  0.8536628  1.3287137
Precision for i (component 1)           0.9783850  0.7767089  1.2274618
Precision for i (component 2)           1.4771635  1.1474891  1.8748224
Rho1:2 for i                            0.7565963  0.6793477  0.8226678
```

---

# The `copy` feature: implementation with `inlabru`


```r
&gt; # Model components
&gt; comp = y ~ eff(i, model = "iid2d", n = 2*n) + eff2(j, z, copy = "eff", fixed=T) 
```
Note that in `inlabru` when using `copy` we refer to the effect name and not to the index name.


```r
&gt; # Likelihood
&gt; lik = like("gaussian",
+            formula = y ~ + eff + eff2,
+            data = data.frame(y = y, z = z, i = i, j = j))
&gt; 
&gt; # Run inlabru
&gt; resultinlabru = bru(comp, lik)
&gt; resultinlabru$summary.hyperpar[,c("mean", "0.025quant", "0.975quant")]
```

```
                                             mean 0.025quant 0.975quant
Precision for the Gaussian observations 1.1338876  0.7552099  1.6477099
Precision for eff (component 1)         0.9466587  0.5844661  1.4266440
Precision for eff (component 2)         1.5311295  1.0203687  2.2336774
Rho1:2 for eff                          0.7430300  0.6308005  0.8315172
```

---

name: stinlabru
  
&lt;span style="display:block; margin-top: 250px ;"&gt;&lt;/span&gt;

.myblue[.center[.huge[
**Two likelihoods model with shared spatial effect using `inlabru`**]]]



---

# Two likelihoods and shared spatial effect: example

.panelset[
.panel[.panel-name[Model]

- We consider two sets of observations in space (with `\(n_1\)` and `\(n_2\)` locations):
`\begin{align}
y_{1i} &amp;\sim \text{Normal}(\beta_1 +\gamma_1 x_{i} + \xi_{i}, \sigma^2_1) \qquad i=1,\ldots,n\\
y_{2i} &amp;\sim \text{Normal}(\beta_2 +\gamma_2 z_{i} + \xi_{i}, \sigma^2_2)\qquad i=1,\ldots,m\\
\end{align}`

&lt;span style="display:block; margin-top: 10px ;"&gt;&lt;/span&gt;
- Each set of data has its own intercept ($\beta_1$ and `\(\beta_2\)`) and covariate (with `\(\gamma_1\)` and `\(\gamma_2\)` as linear effect).
&lt;span style="display:block; margin-top: 10px ;"&gt;&lt;/span&gt;
- The random effect `\(\xi\)` is a  shared GF with range `\(r\)` and variance `\(\sigma^2\)`.  It enters both in the linear predictor of `\(y_1\)` and `\(y_2\)`.
&lt;span style="display:block; margin-top: 10px ;"&gt;&lt;/span&gt;
- For the simulation we use: `\(n=100\)`, `\(m=50\)`, `\(\beta_1=3\)`, `\(\gamma_1=2\)`, `\(\sigma^2_1=0.3\)`, `\(\beta_2=10\)`, `\(\gamma_2=0.5\)`, `\(\sigma^2_2=0.2\)`, `\(r=4\)`, `\(\sigma^2=\sqrt{0.5}\)`.
]


.panel[.panel-name[Data]
.pull-left[


```r
&gt; loc_all %&gt;% 
+   ggplot() +
+   gg(mesh) +
+   geom_point(aes(s1,s2,col=lik))
```
]
.pull-right[
&lt;img src="./img/mesh1out-1.png" &gt;
]
]
]

---
# Implementation in `inlabru`

1\. Define the SPDE model:

```r
&gt; spde &lt;- inla.spde2.pcmatern(
+   mesh = mesh,
+   prior.range = c(1, 0.01), # P(range &lt; 1) = 0.01
+   prior.sigma = c(1, 0.01)) # P(sigma &gt; 1) = 0.01
```


2\. We write down all the model components of the joint model:

```r
&gt; jcmp &lt;- ~ Intercept1(1) + Intercept2(1) +
+   beta1(x1, model="linear") + beta2(x2, model="linear") + 
+   field(coordinates, model = spde)
```

3\. We specify the two likelihoods:

```r
&gt; lik1 &lt;- like("gaussian",
+              formula = y ~ Intercept1 + beta1 + field,
+              data = df1)
&gt; lik2 &lt;- like("gaussian",
+              formula = y ~ Intercept2 + beta2 + field,
+              data = df2)
```

---
# Implementation in `inlabru` and output summary
4\. We run `inlabru`:

```r
&gt; jfit &lt;- bru(jcmp, lik1, lik2)
```



```r
&gt; jfit$summary.fixed[,c("mean","0.025quant","0.975quant")]
```

```
                mean 0.025quant 0.975quant
Intercept1  3.562606  2.3544165   4.773242
Intercept2 10.138851  8.9264961  11.362755
beta1       2.020479  1.1985237   2.841611
beta2       1.120432  0.3123589   1.931600
```

```r
&gt; jfit$summary.hyperpar[,c("mean","0.025quant","0.975quant")]
```

```
                                                mean 0.025quant 0.975quant
Precision for the Gaussian observations    0.8223147  0.5876694   1.114021
Precision for the Gaussian observations[2] 0.9598422  0.6834580   1.303628
Range for field                            4.3916432  2.2068024   8.376719
Stdev for field                            0.8570362  0.5722699   1.231279
```

---

# Fixed effects


.pull-left[
&lt;img src="./img/fixedeffectout-1.png" &gt;
]
.pull-right[
&lt;img src="./img/fixedeffectout2-1.png" &gt;
]

---

# Spatial parameters
.pull-left[

```r
&gt; spde.range &lt;- spde.posterior(jfit,
+                              "field",
+                              what = "range")
&gt; spde.var &lt;- spde.posterior(jfit,
+                            "field",
+                            what = "variance")
```
]
.pull-right[


&lt;img src="./img/spatialparout-1.png" &gt;
]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="https://platform.twitter.com/widgets.js"></script>
<script>var slideshow = remark.create({
"navigation": {
"scroll": false
},
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<style>
.logo {
  background-image: url("assets/MRC-Centre-Logo.png");
  background-size: 15% 10%;
  background-repeat: no-repeat;
  position: absolute;
  top:  0.25%; /* 1.135em */
  left: 85%;
  width: 100%;
  height: 100%;
  z-index: 0;
}
</style>

<script>
document
  .querySelectorAll(
    '.remark-slide-content' +
    ':not(.title-slide)' +
    // add additional classes to exclude here, e.g.
    // ':not(.inverse)' +
    ':not(.hide-logo)' +
    ':not(.thankyou-michelle)' +
    ':not(.thankyou-barney)'
  )
  .forEach(el => {
    el.innerHTML += '<div class="logo"></div>';
  });
</script>


<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
